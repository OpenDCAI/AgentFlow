[
    {
        "page_id": 0,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "title",
                "bbox": [
                    421,
                    280,
                    2061,
                    424
                ],
                "angle": 0,
                "content": "CodeBERT: A Pre-Trained Model for Programming and Natural Languages"
            },
            {
                "block_id": 1,
                "type": "text",
                "bbox": [
                    421,
                    466,
                    2066,
                    589
                ],
                "angle": 0,
                "content": "Zhangyin Feng\\(^{1*}\\), Daya Guo\\(^{2*}\\), Duyu Tang\\(^{3}\\), Nan Duan\\(^{3}\\), Xiaocheng Feng\\(^{1}\\), Ming Gong\\(^{4}\\), Linjun Shou\\(^{4}\\), Bing Qin\\(^{1}\\), Ting Liu\\(^{1}\\), Daxin Jiang\\(^{4}\\), Ming Zhou\\(^{3}\\)"
            },
            {
                "block_id": 2,
                "type": "text",
                "bbox": [
                    186,
                    589,
                    2309,
                    648
                ],
                "angle": 0,
                "content": "<sup>1</sup> Research Center for Social Computing and Information Retrieval, Harbin Institute of Technology, China"
            },
            {
                "block_id": 3,
                "type": "text",
                "bbox": [
                    488,
                    648,
                    2009,
                    705
                ],
                "angle": 0,
                "content": "2 The School of Data and Computer Science, Sun Yat-sen University, China"
            },
            {
                "block_id": 4,
                "type": "text",
                "bbox": [
                    821,
                    701,
                    1677,
                    764
                ],
                "angle": 0,
                "content": "<sup>3</sup> Microsoft Research Asia, Beijing, China"
            },
            {
                "block_id": 5,
                "type": "text",
                "bbox": [
                    650,
                    764,
                    1850,
                    824
                ],
                "angle": 0,
                "content": "<sup>4</sup> Microsoft Search Technology Center Asia, Beijing, China"
            },
            {
                "block_id": 6,
                "type": "text",
                "bbox": [
                    687,
                    824,
                    1843,
                    880
                ],
                "angle": 0,
                "content": "{zyfeng,xcfeng,qinb,tliu}@ir.hit.edu.cn"
            },
            {
                "block_id": 7,
                "type": "text",
                "bbox": [
                    888,
                    887,
                    1610,
                    936
                ],
                "angle": 0,
                "content": "guody5@mail2.sysu.edu.cn"
            },
            {
                "block_id": 8,
                "type": "text",
                "bbox": [
                    384,
                    940,
                    2116,
                    999
                ],
                "angle": 0,
                "content": "{dutang, nanduan, migon, lisho, djiang, mingzhou}@microsoft.com"
            },
            {
                "block_id": 9,
                "type": "title",
                "bbox": [
                    652,
                    1087,
                    850,
                    1143
                ],
                "angle": 0,
                "content": "Abstract"
            },
            {
                "block_id": 10,
                "type": "text",
                "bbox": [
                    354,
                    1199,
                    1151,
                    2652
                ],
                "angle": 0,
                "content": "We present CodeBERT, a bimodal pre-trained model for programming language (PL) and natural language (NL). CodeBERT learns general-purpose representations that support downstream NL-PL applications such as natural language code search, code documentation generation, etc. We develop CodeBERT with Transformer-based neural architecture, and train it with a hybrid objective function that incorporates the pre-training task of replaced token detection, which is to detect plausible alternatives sampled from generators. This enables us to utilize both \"bimodal\" data of NL-PL pairs and \"unimodal\" data, where the former provides input tokens for model training while the latter helps to learn better generators. We evaluate CodeBERT on two NL-PL applications by fine-tuning model parameters. Results show that CodeBERT achieves state-of-the-art performance on both natural language code search and code documentation generation. Furthermore, to investigate what type of knowledge is learned in CodeBERT, we construct a dataset for NL-PL probing, and evaluate in a zero-shot setting where parameters of pre-trained models are fixed. Results show that CodeBERT performs better than previous pre-trained models on NL-PL probing.<sup>1</sup>"
            },
            {
                "block_id": 11,
                "type": "title",
                "bbox": [
                    290,
                    2704,
                    650,
                    2760
                ],
                "angle": 0,
                "content": "1 Introduction"
            },
            {
                "block_id": 12,
                "type": "text",
                "bbox": [
                    285,
                    2806,
                    1218,
                    2978
                ],
                "angle": 0,
                "content": "Large pre-trained models such as ELMo (Peters et al., 2018), GPT (Radford et al., 2018), BERT (Devlin et al., 2018), XLNet (Yang et al., 2019)"
            },
            {
                "block_id": 13,
                "type": "text",
                "bbox": [
                    1265,
                    1090,
                    2200,
                    1936
                ],
                "angle": 0,
                "content": "and RoBERTa (Liu et al., 2019) have dramatically improved the state-of-the-art on a variety of natural language processing (NLP) tasks. These pre-trained models learn effective contextual representations from massive unlabeled text optimized by self-supervised objectives, such as masked language modeling, which predicts the original masked word from an artificially masked input sequence. The success of pre-trained models in NLP also drives a surge of multi-modal pre-trained models, such as ViLBERT (Lu et al., 2019) for language-image and VideoBERT (Sun et al., 2019) for language-video, which are learned from bi-modal data such as language-image pairs with bi-modal self-supervised objectives."
            },
            {
                "block_id": 14,
                "type": "text",
                "bbox": [
                    1265,
                    1946,
                    2200,
                    3125
                ],
                "angle": 0,
                "content": "In this work, we present CodeBERT, a bimodal pre-trained model for natural language (NL) and programming language (PL) like Python, Java, JavaScript, etc. CodeBERT captures the semantic connection between natural language and programming language, and produces general-purpose representations that can broadly support NL-PL understanding tasks (e.g. natural language code search) and generation tasks (e.g. code documentation generation). It is developed with the multilayer Transformer (Vaswani et al., 2017), which is adopted in a majority of large pre-trained models. In order to make use of both bimodal instances of NL-PL pairs and large amount of available unimodal codes, we train CodeBERT with a hybrid objective function, including standard masked language modeling (Devlin et al., 2018) and replaced token detection (Clark et al., 2020), where unimodal codes help to learn better generators for producing better alternative tokens for the latter objective."
            },
            {
                "block_id": 15,
                "type": "text",
                "bbox": [
                    1314,
                    3136,
                    2198,
                    3192
                ],
                "angle": 0,
                "content": "We train CodeBERT from Github code reposito-"
            },
            {
                "block_id": 16,
                "type": "page_footnote",
                "bbox": [
                    287,
                    3009,
                    1215,
                    3101
                ],
                "angle": 0,
                "content": "*Work done while this author was an intern at Microsoft Research Asia."
            },
            {
                "block_id": 17,
                "type": "page_footnote",
                "bbox": [
                    292,
                    3101,
                    1215,
                    3188
                ],
                "angle": 0,
                "content": "1All the codes and data are available at https:// github.com/microsoft/CodeBERT"
            },
            {
                "block_id": 18,
                "type": "list",
                "bbox": [
                    287,
                    3009,
                    1215,
                    3188
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 19,
                "type": "page_number",
                "bbox": [
                    1195,
                    3230,
                    1292,
                    3279
                ],
                "angle": 0,
                "content": "1536"
            },
            {
                "block_id": 20,
                "type": "footer",
                "bbox": [
                    540,
                    3301,
                    1935,
                    3350
                ],
                "angle": 0,
                "content": "Findings of the Association for Computational Linguistics: EMNLP 2020, pages 1536-1547"
            },
            {
                "block_id": 21,
                "type": "footer",
                "bbox": [
                    659,
                    3353,
                    1816,
                    3395
                ],
                "angle": 0,
                "content": "November 16 - 20, 2020. ©2020 Association for Computational Linguistics"
            }
        ]
    },
    {
        "page_id": 1,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "text",
                "bbox": [
                    285,
                    266,
                    1223,
                    1452
                ],
                "angle": 0,
                "content": "ries in 6 programming languages, where bimodal datapoints are codes that pair with function-level natural language documentations (Husain et al., 2019). Training is conducted in a setting similar to that of multilingual BERT (Pires et al., 2019), in which case one pre-trained model is learned for 6 programming languages with no explicit markers used to denote the input programming language. We evaluate CodeBERT on two downstream NL-PL tasks, including natural language code search and code documentation generation. Results show that fine-tuning the parameters of CodeBERT achieves state-of-the-art performance on both tasks. To further investigate what type of knowledge is learned in CodeBERT, we construct a dataset for NL-PL probing, and test CodeBERT in a zero-shot scenario, i.e. without fine-tuning the parameters of CodeBERT. We find that CodeBERT consistently outperforms RoBERTa, a purely natural language-based pre-trained model. The contributions of this work are as follows:"
            },
            {
                "block_id": 1,
                "type": "text",
                "bbox": [
                    342,
                    1490,
                    1215,
                    1662
                ],
                "angle": 0,
                "content": "- CodeBERT is the first large NL-PL pretrained model for multiple programming languages."
            },
            {
                "block_id": 2,
                "type": "text",
                "bbox": [
                    344,
                    1701,
                    1215,
                    1869
                ],
                "angle": 0,
                "content": "- Empirical results show that CodeBERT is effective in both code search and code-to-text generation tasks."
            },
            {
                "block_id": 3,
                "type": "text",
                "bbox": [
                    344,
                    1911,
                    1213,
                    2080
                ],
                "angle": 0,
                "content": "- We further created a dataset which is the first one to investigate the probing ability of the code-based pre-trained models."
            },
            {
                "block_id": 4,
                "type": "list",
                "bbox": [
                    342,
                    1490,
                    1215,
                    2080
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 5,
                "type": "title",
                "bbox": [
                    287,
                    2125,
                    640,
                    2178
                ],
                "angle": 0,
                "content": "2 Background"
            },
            {
                "block_id": 6,
                "type": "title",
                "bbox": [
                    287,
                    2217,
                    947,
                    2266
                ],
                "angle": 0,
                "content": "2.1 Pre-Trained Models in NLP"
            },
            {
                "block_id": 7,
                "type": "text",
                "bbox": [
                    285,
                    2290,
                    1223,
                    3195
                ],
                "angle": 0,
                "content": "Large pre-trained models (Peters et al., 2018; Radford et al., 2018; Devlin et al., 2018; Yang et al., 2019; Liu et al., 2019; Raffel et al., 2019) have brought dramatic empirical improvements on almost every NLP task in the past few years. Successful approaches train deep neural networks on large-scale plain texts with self-supervised learning objectives. One of the most representative neural architectures is the Transformer (Vaswani et al., 2017), which is also the one used in this work. It contains multiple self-attention layers, and can be conventionally learned with gradient decent in an end-to-end manner as every component is differentiable. The terminology \"self-supervised\" means that supervisions used for pre-training are automatically collected from raw data without manual"
            },
            {
                "block_id": 8,
                "type": "text",
                "bbox": [
                    1265,
                    266,
                    2200,
                    1164
                ],
                "angle": 0,
                "content": "annotation. Dominant learning objectives are language modeling and its variations. For example, in GPT (Radford et al., 2018), the learning objective is language modeling, namely predicting the next word \\( w_{k} \\) given the preceding context words \\( \\{w_{1}, w_{2}, \\dots, w_{k-1}\\} \\). As the ultimate goal of pretraining is not to train a good language model, it is desirable to consider both preceding and following contexts to learn better general-purpose contextual representations. This leads us to the masked language modeling objective used in BERT (Devlin et al., 2018), which learns to predict the masked words of a randomly masked word sequence given surrounding contexts. Masked language modeling is also used as one of the two learning objectives for training CodeBERT."
            },
            {
                "block_id": 9,
                "type": "title",
                "bbox": [
                    1267,
                    1234,
                    2036,
                    1283
                ],
                "angle": 0,
                "content": "2.2 Multi-Modal Pre-Trained Models"
            },
            {
                "block_id": 10,
                "type": "text",
                "bbox": [
                    1265,
                    1322,
                    2198,
                    2501
                ],
                "angle": 0,
                "content": "The remarkable success of the pre-trained model in NLP has driven the development of multi-modal pre-trained model that learns implicit alignment between inputs of different modalities. These models are typically learned from bimodal data, such as pairs of language-image or pairs of language-video. For example, ViLBERT (Lu et al., 2019) learns from image caption data, where the model learns by reconstructing categories of masked image region or masked words given the observed inputs, and meanwhile predicting whether the caption describes the image content or not. Similarly, VideoBERT (Sun et al., 2019) learns from language-video data and is trained by video and text masked token prediction. Our work belongs to this line of research as we regard NL and PL as different modalities. Our method differs from previous works in that the fuels for model training include not only bimodal data of NL-PL pairs, but larger amounts of unimodal data such as codes without paired documentations."
            },
            {
                "block_id": 11,
                "type": "text",
                "bbox": [
                    1265,
                    2515,
                    2198,
                    3195
                ],
                "angle": 0,
                "content": "A concurrent work (Kanade et al., 2019) uses masked language modeling and next sentence prediction as the objective to train a BERT model on Python source codes, where a sentence is a logical code line as defined by the Python standard. In terms of the pre-training process, CodeBERT differs from their work in that (1) CodeBERT is trained in a cross-modal style and leverages both bimodal NL-PL data and unimodal PL/NL data, (2) CodeBERT is pre-trained over six programming languages, and (3) CodeBERT is trained with a new learning objective based on replaced token"
            },
            {
                "block_id": 12,
                "type": "page_number",
                "bbox": [
                    1195,
                    3230,
                    1292,
                    3279
                ],
                "angle": 0,
                "content": "1537"
            }
        ]
    },
    {
        "page_id": 2,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "text",
                "bbox": [
                    290,
                    266,
                    478,
                    312
                ],
                "angle": 0,
                "content": "detection."
            },
            {
                "block_id": 1,
                "type": "title",
                "bbox": [
                    287,
                    364,
                    622,
                    417
                ],
                "angle": 0,
                "content": "3 CodeBERT"
            },
            {
                "block_id": 2,
                "type": "text",
                "bbox": [
                    285,
                    459,
                    1218,
                    740
                ],
                "angle": 0,
                "content": "We describe the details about CodeBERT in this section, including the model architecture, the input and output representations, the objectives and data used for training CodeBERT, and how to fine-tune CodeBERT when it is applied to downstream tasks."
            },
            {
                "block_id": 3,
                "type": "title",
                "bbox": [
                    287,
                    785,
                    786,
                    834
                ],
                "angle": 0,
                "content": "3.1 Model Architecture"
            },
            {
                "block_id": 4,
                "type": "text",
                "bbox": [
                    285,
                    859,
                    1215,
                    1311
                ],
                "angle": 0,
                "content": "We follow BERT (Devlin et al., 2018) and RoBERTa (Liu et al., 2019), and use multi-layer bidirectional Transformer (Vaswani et al., 2017) as the model architecture of CodeBERT. We will not review the ubiquitous Transformer architecture in detail. We develop CodeBERT by using exactly the same model architecture as RoBERTa-base. The total number of model parameters is \\(125\\mathrm{M}\\)."
            },
            {
                "block_id": 5,
                "type": "title",
                "bbox": [
                    287,
                    1357,
                    994,
                    1413
                ],
                "angle": 0,
                "content": "3.2 Input/Output Representations"
            },
            {
                "block_id": 6,
                "type": "text",
                "bbox": [
                    285,
                    1431,
                    1218,
                    2220
                ],
                "angle": 0,
                "content": "In the pre-training phase, we set the input as the concatenation of two segments with a special separator token, namely \\([CLS], w_1, w_2,..w_n, [SEP], c_1, c_2, \\ldots, c_m, [EOS]\\). One segment is natural language text, and another is code from a certain programming language. \\([CLS]\\) is a special token in front of the two segments, whose final hidden representation is considered as the aggregated sequence representation for classification or ranking. Following the standard way of processing text in Transformer, we regard a natural language text as a sequence of words, and split it as WordPiece (Wu et al., 2016). We regard a piece of code as a sequence of tokens."
            },
            {
                "block_id": 7,
                "type": "text",
                "bbox": [
                    285,
                    2224,
                    1215,
                    2504
                ],
                "angle": 0,
                "content": "The output of CodeBERT includes (1) contextual vector representation of each token, for both natural language and code, and (2) the representation of \\([CLS]\\), which works as the aggregated sequence representation."
            },
            {
                "block_id": 8,
                "type": "title",
                "bbox": [
                    287,
                    2550,
                    764,
                    2606
                ],
                "angle": 0,
                "content": "3.3 Pre-Training Data"
            },
            {
                "block_id": 9,
                "type": "text",
                "bbox": [
                    285,
                    2623,
                    1215,
                    2904
                ],
                "angle": 0,
                "content": "We train CodeBERT with both bimodal data, which refers to parallel data of natural language-code pairs, and unimodal data, which stands for codes without paired natural language texts and natural language without paired codes."
            },
            {
                "block_id": 10,
                "type": "text",
                "bbox": [
                    285,
                    2911,
                    1218,
                    3192
                ],
                "angle": 0,
                "content": "We use datapoints from Github repositories, where each bimodal datapoint is an individual function with paired documentation, and each unimodal code is a function without paired documentation. Specifically, we use a recent large dataset"
            },
            {
                "block_id": 11,
                "type": "table",
                "bbox": [
                    1277,
                    256,
                    2178,
                    648
                ],
                "angle": 0,
                "content": "<table><tr><td>TRAINING DATA</td><td>bimodal DATA</td><td>unimodal CODES</td></tr><tr><td>GO</td><td>319,256</td><td>726,768</td></tr><tr><td>JAVA</td><td>500,754</td><td>1,569,889</td></tr><tr><td>JAVAsCIPT</td><td>143,252</td><td>1,857,835</td></tr><tr><td>PHP</td><td>662,907</td><td>977,821</td></tr><tr><td>PYTHON</td><td>458,219</td><td>1,156,085</td></tr><tr><td>RUBY</td><td>52,905</td><td>164,048</td></tr><tr><td>ALL</td><td>2,137,293</td><td>6,452,446</td></tr></table>",
                "caption": "Table 1: Statistics of the dataset used for training CodeBERT."
            },
            {
                "block_id": 13,
                "type": "text",
                "bbox": [
                    1262,
                    859,
                    2195,
                    1136
                ],
                "angle": 0,
                "content": "provided by Husain et al. (2019), which includes 2.1M bimodal datapoints and 6.4M unimodal codes across six programming languages (Python, Java, JavaScript, PHP, Ruby, and Go). Data statistics is shown in Table 1.\\(^{2}\\)"
            },
            {
                "block_id": 14,
                "type": "text",
                "bbox": [
                    1262,
                    1143,
                    2200,
                    1704
                ],
                "angle": 0,
                "content": "The data comes from publicly available open-source non-fork GitHub repositories and are filtered with a set of constraints and rules. For example, (1) each project should be used by at least one other project, (2) each documentation is truncated to the first paragraph, (3) documentations shorter than three tokens are removed, (4) functions shorter than three lines are removed, and (5) function names with substring \"test\" are removed. An example of the data is given in Figure 1<sup>3</sup>."
            },
            {
                "block_id": 15,
                "type": "image",
                "bbox": [
                    1277,
                    1743,
                    2193,
                    2245
                ],
                "angle": 0,
                "content": null,
                "caption": "Figure 1: An example of the NL-PL pair, where NL is the first paragraph (filled in red) from the documentation (dashed line in black) of a function."
            },
            {
                "block_id": 17,
                "type": "title",
                "bbox": [
                    1267,
                    2522,
                    1873,
                    2578
                ],
                "angle": 0,
                "content": "3.4 Pre-Training CodeBERT"
            },
            {
                "block_id": 18,
                "type": "text",
                "bbox": [
                    1262,
                    2595,
                    2198,
                    2820
                ],
                "angle": 0,
                "content": "We describe the two objectives used for training CodeBERT here. The first objective is masked language modeling (MLM), which has proven effective in literature (Devlin et al., 2018; Liu et al.,"
            },
            {
                "block_id": 19,
                "type": "page_footnote",
                "bbox": [
                    1265,
                    2844,
                    2198,
                    3020
                ],
                "angle": 0,
                "content": "<sup>2</sup>Since we will evaluate on the natural language code search task, we only use the training data of Husain et al. (2019) to train CodeBERT with no access to the dev and testing data."
            },
            {
                "block_id": 20,
                "type": "page_footnote",
                "bbox": [
                    1265,
                    3020,
                    2200,
                    3192
                ],
                "angle": 0,
                "content": "3The source of the illustrating example comes from https://github.com/apache/spark/blob/618d6bfff71073c8c93501ab7392c3cc579730f0b/pypython/pyspark/rdd.py#L125-L138"
            },
            {
                "block_id": 21,
                "type": "list",
                "bbox": [
                    1265,
                    2844,
                    2200,
                    3192
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 22,
                "type": "page_number",
                "bbox": [
                    1195,
                    3230,
                    1292,
                    3279
                ],
                "angle": 0,
                "content": "1538"
            }
        ]
    },
    {
        "page_id": 3,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "image",
                "bbox": [
                    357,
                    256,
                    2138,
                    1034
                ],
                "angle": 0,
                "content": null,
                "caption": "Figure 2: An illustration about the replaced token detection objective. Both NL and code generators are language models, which generate plausible tokens for masked positions based on surrounding contexts. NL-Code discriminator is the targeted pre-trained model, which is trained via detecting plausible alternatives tokens sampled from NL and PL generators. NL-Code discriminator is used for producing general-purpose representations in the fine-tuning step. Both NL and code generators are thrown out in the fine-tuning step."
            },
            {
                "block_id": 2,
                "type": "text",
                "bbox": [
                    285,
                    1406,
                    1218,
                    1799
                ],
                "angle": 0,
                "content": "2019; Sun et al., 2019). We apply masked language modeling on bimodal data of NL-PL pairs. The second objective is replaced token detection (RTD), which further uses a large amount of unimodal data, such as codes without paired natural language texts. Detailed hyper-parameters for model pre-training are given in Appendix B.1."
            },
            {
                "block_id": 3,
                "type": "text",
                "bbox": [
                    285,
                    1831,
                    1215,
                    2339
                ],
                "angle": 0,
                "content": "Objective #1: Masked Language Modeling (MLM) Given a datapoint of NL-PL pair \\((x = \\{w, c\\})\\) as input, where \\(w\\) is a sequence of NL words and \\(c\\) is a sequence of PL tokens, we first select a random set of positions for both NL and PL to mask out (i.e. \\(mw\\) and \\(mc^c\\), respectively), and then replace the selected positions with a special [MASK] token. Following Devlin et al. (2018), \\(15\\%\\) of the tokens from \\(x\\) are masked out."
            },
            {
                "block_id": 4,
                "type": "equation",
                "bbox": [
                    401,
                    2378,
                    1213,
                    2441
                ],
                "angle": 0,
                "content": "\\[\nm _ {i} ^ {w} \\sim \\operatorname {u n i f} \\{1, | \\boldsymbol {w} | \\} \\text {f o r} i = 1 \\text {t o} | \\boldsymbol {w} | \\tag {1}\n\\]"
            },
            {
                "block_id": 5,
                "type": "equation",
                "bbox": [
                    416,
                    2448,
                    1210,
                    2511
                ],
                "angle": 0,
                "content": "\\[\nm _ {i} ^ {c} \\sim \\operatorname {u n i f} \\{1, | \\boldsymbol {c} | \\} \\mathrm {f o r} i = 1 \\mathrm {t o} | \\boldsymbol {c} | \\tag {2}\n\\]"
            },
            {
                "block_id": 6,
                "type": "equation",
                "bbox": [
                    334,
                    2518,
                    1210,
                    2581
                ],
                "angle": 0,
                "content": "\\[\n\\boldsymbol {w} ^ {\\text {m a s k e d}} = \\operatorname {R E P L A C E} \\left(\\boldsymbol {w}, \\boldsymbol {m} ^ {\\boldsymbol {w}}, [ M A S K ]\\right) \\tag {3}\n\\]"
            },
            {
                "block_id": 7,
                "type": "equation",
                "bbox": [
                    344,
                    2592,
                    1210,
                    2655
                ],
                "angle": 0,
                "content": "\\[\n\\boldsymbol {c} ^ {\\text {m a s k e d}} = \\operatorname {R E P L A C E} \\left(\\boldsymbol {c}, \\boldsymbol {m} ^ {\\boldsymbol {c}}, [ M A S K ]\\right) \\tag {4}\n\\]"
            },
            {
                "block_id": 8,
                "type": "equation",
                "bbox": [
                    444,
                    2673,
                    1210,
                    2722
                ],
                "angle": 0,
                "content": "\\[\n\\boldsymbol {x} = \\boldsymbol {w} + \\boldsymbol {c} \\tag {5}\n\\]"
            },
            {
                "block_id": 9,
                "type": "text",
                "bbox": [
                    285,
                    2767,
                    1218,
                    2995
                ],
                "angle": 0,
                "content": "The MLM objective is to predict the original tokens which are masked out, formulated as follows, where \\( p^{D_1} \\) is the discriminator which predicts a token from a large vocabulary."
            },
            {
                "block_id": 10,
                "type": "equation",
                "bbox": [
                    292,
                    3027,
                    1210,
                    3192
                ],
                "angle": 0,
                "content": "\\[\n\\mathcal {L} _ {\\mathrm {M L M}} (\\theta) = \\sum_ {i \\in \\boldsymbol {m} ^ {\\boldsymbol {w}} \\cup \\boldsymbol {m} ^ {\\boldsymbol {c}}} - \\log p ^ {D _ {1}} \\left(x _ {i} | \\boldsymbol {w} ^ {\\text {m a s k e d}}, \\boldsymbol {c} ^ {\\text {m a s k e d}}\\right) \\tag {6}\n\\]"
            },
            {
                "block_id": 11,
                "type": "text",
                "bbox": [
                    1265,
                    1406,
                    2195,
                    2139
                ],
                "angle": 0,
                "content": "Objective #2: Replaced Token Detection (RTD) In the MLM objective, only bimodal data (i.e. datapoints of NL-PL pairs) is used for training. Here we present the objective of replaced token detection. The RTD objective (Clark et al., 2020) is originally developed for efficiently learning pre-trained model for natural language. We adapt it in our scenario, with the advantage of using both bimodal and unimodal data for training. Specifically, there are two data generators here, an NL generator \\( p^{G_w} \\) and a PL generator \\( p^{G_c} \\), both for generating plausible alternatives for the set of randomly masked positions."
            },
            {
                "block_id": 12,
                "type": "equation",
                "bbox": [
                    1401,
                    2171,
                    2193,
                    2238
                ],
                "angle": 0,
                "content": "\\[\n\\hat {w} _ {i} \\sim p ^ {G _ {w}} \\left(w _ {i} \\mid \\boldsymbol {w} ^ {\\text {m a s k e d}}\\right) \\text {f o r} i \\in \\boldsymbol {m} ^ {\\boldsymbol {w}} \\tag {7}\n\\]"
            },
            {
                "block_id": 13,
                "type": "equation",
                "bbox": [
                    1414,
                    2245,
                    2190,
                    2311
                ],
                "angle": 0,
                "content": "\\[\n\\hat {c} _ {i} \\sim p ^ {G _ {c}} \\left(c _ {i} \\mid c ^ {\\text {m a s k e d}}\\right) \\text {f o r} i \\in \\boldsymbol {m} ^ {\\boldsymbol {c}} \\tag {8}\n\\]"
            },
            {
                "block_id": 14,
                "type": "equation",
                "bbox": [
                    1409,
                    2388,
                    2190,
                    2452
                ],
                "angle": 0,
                "content": "\\[\n\\boldsymbol {w} ^ {\\text {c o r r u p t}} = \\operatorname {R E P L A C E} (\\boldsymbol {w}, \\boldsymbol {m} ^ {\\boldsymbol {w}}, \\hat {\\boldsymbol {w}}) \\tag {9}\n\\]"
            },
            {
                "block_id": 15,
                "type": "equation",
                "bbox": [
                    1426,
                    2459,
                    2188,
                    2518
                ],
                "angle": 0,
                "content": "\\[\n\\boldsymbol {c} ^ {\\text {c o r r u p t}} = \\operatorname {R E P L A C E} \\left(\\boldsymbol {c}, \\boldsymbol {m} ^ {\\boldsymbol {c}}, \\hat {\\boldsymbol {c}}\\right) \\tag {10}\n\\]"
            },
            {
                "block_id": 16,
                "type": "equation",
                "bbox": [
                    1421,
                    2525,
                    2188,
                    2585
                ],
                "angle": 0,
                "content": "\\[\n\\boldsymbol {x} ^ {\\text {c o r r u p t}} = \\boldsymbol {w} ^ {\\text {c o r r u p t}} + \\boldsymbol {c} ^ {\\text {c o r r u p t}} \\tag {11}\n\\]"
            },
            {
                "block_id": 17,
                "type": "text",
                "bbox": [
                    1265,
                    2627,
                    2195,
                    3195
                ],
                "angle": 0,
                "content": "The discriminator is trained to determine whether a word is the original one or not, which is a binary classification problem. It is worth noting that the RTD objective is applied to every position in the input, and it differs from GAN (generative adversarial network) in that if a generator happens to produce the correct token, the label of that token is \"real\" instead of \"fake\" (Clark et al., 2020). The loss function of RTD with regard to the discriminator parameterized by \\(\\theta\\) is given below, where \\(\\delta(i)\\) is"
            },
            {
                "block_id": 18,
                "type": "page_number",
                "bbox": [
                    1195,
                    3230,
                    1292,
                    3279
                ],
                "angle": 0,
                "content": "1539"
            }
        ]
    },
    {
        "page_id": 4,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "text",
                "bbox": [
                    285,
                    263,
                    1215,
                    431
                ],
                "angle": 0,
                "content": "an indicator function and \\( p^{D_2} \\) is the discriminator that predicts the probability of the \\( i \\)-th word being original."
            },
            {
                "block_id": 1,
                "type": "equation",
                "bbox": [
                    287,
                    473,
                    1213,
                    813
                ],
                "angle": 0,
                "content": "\\[\n\\begin{array}{l} \\mathcal {L} _ {\\mathrm {R T D}} (\\theta) = \\sum_ {i = 1} ^ {| \\boldsymbol {w} | + | \\boldsymbol {c} |} \\left(\\delta (i) \\log p ^ {D _ {2}} (\\boldsymbol {x} ^ {\\text {c o r r u p t}}, i) + \\right. \\\\ \\left. \\left(1 - \\delta (i)\\right) \\left(1 - \\log p ^ {D _ {2}} \\left(\\boldsymbol {x} ^ {\\text {c o r r u p t}}, i\\right)\\right)\\right) \\tag {12} \\\\ \\end{array}\n\\]"
            },
            {
                "block_id": 2,
                "type": "equation",
                "bbox": [
                    476,
                    859,
                    1213,
                    1006
                ],
                "angle": 0,
                "content": "\\[\n\\delta (i) = \\left\\{ \\begin{array}{l l} 1, & \\text {i f} x _ {i} ^ {\\text {c o r r u p t}} = x _ {i}. \\\\ 0, & \\text {o t h e r w i s e .} \\end{array} \\right. \\tag {13}\n\\]"
            },
            {
                "block_id": 3,
                "type": "text",
                "bbox": [
                    285,
                    1024,
                    1215,
                    1866
                ],
                "angle": 0,
                "content": "There are many different ways to implement the generators. In this work, we implement two efficient n-gram language models (Jurafsky, 2000) with bidirectional contexts, one for NL and one for PL, and learn them from corresponding unimodel datapoints, respectively. The approach is easily generalized to learn bimodal generators or use more complicated generators like Transformer-based neural architecture learned in a joint manner. We leave these to future work. The PL training data is the unimodal codes as shown in Table 1, and the NL training data comes from the documentations from bimodal data. One could easily extend these two training datasets to larger amount. The final loss function are given below."
            },
            {
                "block_id": 4,
                "type": "equation",
                "bbox": [
                    508,
                    1911,
                    1210,
                    1996
                ],
                "angle": 0,
                "content": "\\[\n\\min  _ {\\theta} \\mathcal {L} _ {\\mathrm {M L M}} (\\theta) + \\mathcal {L} _ {\\mathrm {R T D}} (\\theta) \\tag {14}\n\\]"
            },
            {
                "block_id": 5,
                "type": "title",
                "bbox": [
                    287,
                    2031,
                    878,
                    2083
                ],
                "angle": 0,
                "content": "3.5 Fine-Tuning CodeBERT"
            },
            {
                "block_id": 6,
                "type": "text",
                "bbox": [
                    285,
                    2104,
                    1215,
                    2666
                ],
                "angle": 0,
                "content": "We have different settings to use CodeBERT in downstream NL-PL tasks. For example, in natural language code search, we feed the input as the same way as the pre-training phase and use the representation of \\([CLS]\\) to measure the semantic relevance between code and natural language query, while in code-to-text generation, we use an encoder-decoder framework and initialize the encoder of a generative model with CodeBERT. Details are given in the experiment section."
            },
            {
                "block_id": 7,
                "type": "title",
                "bbox": [
                    287,
                    2708,
                    630,
                    2767
                ],
                "angle": 0,
                "content": "4 Experiment"
            },
            {
                "block_id": 8,
                "type": "text",
                "bbox": [
                    285,
                    2795,
                    1215,
                    3192
                ],
                "angle": 0,
                "content": "We present empirical results in this section to verify the effectiveness of CodeBERT. We first describe the use of CodeBERT in natural language code search (§4.1), in a way that model parameters of CodeBERT are fine-tuned. After that, we present the NL-PL probing task (§4.2), and evaluate CodeBERT in a zero-shot setting where the parameters"
            },
            {
                "block_id": 9,
                "type": "text",
                "bbox": [
                    1265,
                    263,
                    2198,
                    547
                ],
                "angle": 0,
                "content": "of CodeBERT are fixed. Finally, we evaluate CodeBERT on a generation problem, i.e. code documentation generation (§4.3), and further evaluate on a programming language which is never seen in the training phase (§4.4)."
            },
            {
                "block_id": 10,
                "type": "title",
                "bbox": [
                    1265,
                    592,
                    1999,
                    648
                ],
                "angle": 0,
                "content": "4.1 Natural Language Code Search"
            },
            {
                "block_id": 11,
                "type": "text",
                "bbox": [
                    1262,
                    673,
                    2198,
                    1971
                ],
                "angle": 0,
                "content": "Given a natural language as the input, the objective of code search is to find the most semantically related code from a collection of codes. We conduct experiments on the CodeSearchNet corpus (Husain et al., 2019) \\(^{4}\\). We follow the official evaluation metric to calculate the Mean Reciprocal Rank (MRR) for each pair of test data \\((c, w)\\) over a fixed set of 999 distractor codes. We further calculate the macro-average MRR for all languages as an overall evaluation metric. It is helpful to note that this metric differs from the AVG metric in the original paper, where the answer is retrieved from candidates from all six languages. We fine-tune a language-specific model for each programming language \\(^{5}\\). We train each model with a binary classification loss function, where a softmax layer is connected to the representation of [CLS]. Both training and validation datasets are created in a way that positive and negative samples are balanced. Negative samples consist of balanced number of instances with randomly replaced NL (i.e. \\((c, \\hat{w})\\)) and PL (i.e. \\((\\hat{c}, w)\\)). Detailed hyper-parameters for model fine-tuning are given in Appendix B.2."
            },
            {
                "block_id": 12,
                "type": "text",
                "bbox": [
                    1265,
                    2010,
                    2198,
                    2627
                ],
                "angle": 0,
                "content": "Model Comparisons Table 2 shows the results of different approaches on the CodeSearchNet corpus. The first four rows are reported by Husain et al. (2019), which are joint embeddings of NL and PL (Gu et al., 2018; Mitra et al., 2018). NBOW represents neural bag-of-words. CNN, BIRNN and SELFATT stand for 1D convolutional neural network (Kim, 2014), bidirectional GRU-based recurrent neural network (Cho et al., 2014), and multi-head attention (Vaswani et al., 2017), respectively."
            },
            {
                "block_id": 13,
                "type": "text",
                "bbox": [
                    1265,
                    2634,
                    2198,
                    2974
                ],
                "angle": 0,
                "content": "We report the remaining numbers in Table 2. We train all these pre-trained models by regarding codes as a sequence of tokens. We also continuously train RoBERTa only on codes from CodeSearchNet with masked language modeling. Results show that CodeBERT consistently performs"
            },
            {
                "block_id": 14,
                "type": "page_footnote",
                "bbox": [
                    1262,
                    3013,
                    2198,
                    3195
                ],
                "angle": 0,
                "content": "4More details about the dataset are given in Appendix A. 5We have fine-tuned a multi-lingual model for six program-. ming languages, but find that it performs worse that fine-tuning a language-specific model for each programming language."
            },
            {
                "block_id": 15,
                "type": "page_number",
                "bbox": [
                    1195,
                    3230,
                    1292,
                    3279
                ],
                "angle": 0,
                "content": "1540"
            }
        ]
    },
    {
        "page_id": 5,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "table",
                "bbox": [
                    295,
                    256,
                    2195,
                    817
                ],
                "angle": 0,
                "content": "<table><tr><td>MODEL</td><td>RUBY</td><td>JAVASCIPT</td><td>GO</td><td>PYTHON</td><td>JAVA</td><td>PHP</td><td>MA-AVG</td></tr><tr><td>NBOW</td><td>0.4285</td><td>0.4607</td><td>0.6409</td><td>0.5809</td><td>0.5140</td><td>0.4835</td><td>0.5181</td></tr><tr><td>CNN</td><td>0.2450</td><td>0.3523</td><td>0.6274</td><td>0.5708</td><td>0.5270</td><td>0.5294</td><td>0.4753</td></tr><tr><td>BIRNN</td><td>0.0835</td><td>0.1530</td><td>0.4524</td><td>0.3213</td><td>0.2865</td><td>0.2512</td><td>0.2580</td></tr><tr><td>SELFATT</td><td>0.3651</td><td>0.4506</td><td>0.6809</td><td>0.6922</td><td>0.5866</td><td>0.6011</td><td>0.5628</td></tr><tr><td>ROBERTA</td><td>0.6245</td><td>0.6060</td><td>0.8204</td><td>0.8087</td><td>0.6659</td><td>0.6576</td><td>0.6972</td></tr><tr><td>PT w/ CODE ONLY (INIT=S)</td><td>0.5712</td><td>0.5557</td><td>0.7929</td><td>0.7855</td><td>0.6567</td><td>0.6172</td><td>0.6632</td></tr><tr><td>PT w/ CODE ONLY (INIT=R)</td><td>0.6612</td><td>0.6402</td><td>0.8191</td><td>0.8438</td><td>0.7213</td><td>0.6706</td><td>0.7260</td></tr><tr><td>CODEBERT (MLM, INIT=S)</td><td>0.5695</td><td>0.6029</td><td>0.8304</td><td>0.8261</td><td>0.7142</td><td>0.6556</td><td>0.6998</td></tr><tr><td>CODEBERT (MLM, INIT=R)</td><td>0.6898</td><td>0.6997</td><td>0.8383</td><td>0.8647</td><td>0.7476</td><td>0.6893</td><td>0.7549</td></tr><tr><td>CODEBERT (RTD, INIT=R)</td><td>0.6414</td><td>0.6512</td><td>0.8285</td><td>0.8263</td><td>0.7150</td><td>0.6774</td><td>0.7233</td></tr><tr><td>CODEBERT (MLM+RTD, INIT=R)</td><td>0.6926</td><td>0.7059</td><td>0.8400</td><td>0.8685</td><td>0.7484</td><td>0.7062</td><td>0.7603</td></tr></table>",
                "caption": "Table 2: Results on natural language code retrieval. Baselines include four joint embeddings (first group) of NL and PL, RoBERTa, and RoBERTa which is continuously trained with masked language modeling on codes only (second group). PT stands for pre-training. We train CodeBERT (third group) with different settings, including using different initialization (from scratch (INIT=S) or initialized with the parameters of RoBERTa (INIT=R)) and using different learning objectives (MLM, RTD, or the combination of both)."
            },
            {
                "block_id": 2,
                "type": "text",
                "bbox": [
                    285,
                    1213,
                    1215,
                    1497
                ],
                "angle": 0,
                "content": "better than RoBERTa and the model pre-trained with code only. CodeBERT (MLM) learned from scratch performs better than RoBERTa. Unsurprisingly, initializing CodeBERT with RoBERTa improves the performance \\(^{6}\\)."
            },
            {
                "block_id": 3,
                "type": "title",
                "bbox": [
                    287,
                    1540,
                    712,
                    1596
                ],
                "angle": 0,
                "content": "4.2 NL-PL Probing"
            },
            {
                "block_id": 4,
                "type": "text",
                "bbox": [
                    285,
                    1617,
                    1218,
                    1953
                ],
                "angle": 0,
                "content": "In the previous subsection, we show the empirical effectiveness of CodeBERT in a setting that the parameters of CodeBERT are fine-tuned in downstream tasks. In this subsection, we further investigate what type of knowledge is learned in CodeBERT without modifying the parameters."
            },
            {
                "block_id": 5,
                "type": "text",
                "bbox": [
                    285,
                    1989,
                    1220,
                    3069
                ],
                "angle": 0,
                "content": "Task Formulation and Data Construction Following the probing experiments in NLP (Petroni et al., 2019; Talmor et al., 2019), we study NL-PL probing here. Since there is no existing work towards this goal, we formulate the problem of NL-PL probing and create the dataset by ourselves. Given an NL-PL pair \\((c, w)\\), the goal of NL-PL probing is to test model's ability to correctly predict/recover the masked token of interest (either a code token \\(c_i\\) or word token \\(w_j\\)) among distractors. There are two major types of distractors: one is the whole target vocabulary used for the masked language modeling objective (Petroni et al., 2019), and another one has fewer candidates which are filter or curated based on experts' understanding about the ability to be tested (Talmor et al., 2019). We follow the second direction and formulate NL-PL probing as a multi-choice question answering task, where the question is cloze-style in which a certain token"
            },
            {
                "block_id": 6,
                "type": "text",
                "bbox": [
                    1265,
                    1213,
                    2193,
                    1326
                ],
                "angle": 0,
                "content": "is replaced by \\([MASK]\\) and distractor candidate answers are curated based on our expertise."
            },
            {
                "block_id": 7,
                "type": "text",
                "bbox": [
                    1262,
                    1333,
                    2198,
                    2918
                ],
                "angle": 0,
                "content": "Specifically, we evaluate on the NL side and PL side, respectively. To ease the effort of data collection, we collect data automatically from NL-PL pairs in both validation and testing sets of CodeSearchNet, both of which are unseen in the pretraining phase. To evaluate on the NL side, we select NL-PL pairs whose NL documentations include one of the six keywords (max, maximize, min, minimize, less, greater), and group them to four candidates by merging first two keywords and the middle two keywords. The task is to ask pre-trained models to select the correct one instead of three other distractors. That is to say, the input in this setting includes the complete code and a masked NL documentation. The goal is to select the correct answer from four candidates. For the PL side, we select codes containing keywords max and min, and formulate the task as a two-choice answer selection problem. Here, the input includes complete NL documentation and a masked PL code, and the goal is to select the correct answer from two candidates. Since code completion is an important scenario, we would like to test model's ability in predicting the correct token merely based on preceding PL contexts. Therefore, we add an additional setting for PL side, where the input includes the complete NL documentation and preceding PL codes. Data statistics is given in the top two rows in Table 3."
            },
            {
                "block_id": 8,
                "type": "text",
                "bbox": [
                    1265,
                    2967,
                    2195,
                    3195
                ],
                "angle": 0,
                "content": "Model Comparisons Results are given in Table 3. We report accuracy, namely the number of correctly predicted instances over the number of all instances, for each programming language. Since"
            },
            {
                "block_id": 9,
                "type": "page_footnote",
                "bbox": [
                    287,
                    3097,
                    1213,
                    3192
                ],
                "angle": 0,
                "content": "<sup>6</sup>We further give a learning curve of different pre-trained models in the fine-tuning process in Appendix C."
            },
            {
                "block_id": 10,
                "type": "page_number",
                "bbox": [
                    1195,
                    3230,
                    1287,
                    3279
                ],
                "angle": 0,
                "content": "1541"
            }
        ]
    },
    {
        "page_id": 6,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "table",
                "bbox": [
                    315,
                    252,
                    2163,
                    1013
                ],
                "angle": 0,
                "content": "<table><tr><td></td><td>RUBY</td><td>JAVASCIPT</td><td>GO</td><td>PYTHON</td><td>JAVA</td><td>PHP</td><td>ALL</td></tr><tr><td colspan=\"8\">NUMBER OF DATAPoints FOR PROBING</td></tr><tr><td>PL (2 CHOICES)</td><td>38</td><td>272</td><td>152</td><td>1,264</td><td>482</td><td>407</td><td>2,615</td></tr><tr><td>NL (4 CHOICES)</td><td>20</td><td>65</td><td>159</td><td>216</td><td>323</td><td>73</td><td>856</td></tr><tr><td colspan=\"8\">PL PROBING</td></tr><tr><td>ROBERTA</td><td>73.68</td><td>63.97</td><td>72.37</td><td>59.18</td><td>59.96</td><td>69.78</td><td>62.45</td></tr><tr><td>PRE-TRAIN W/ CODE ONLY</td><td>71.05</td><td>77.94</td><td>89.47</td><td>70.41</td><td>70.12</td><td>82.31</td><td>74.11</td></tr><tr><td>CODEBERT (MLM)</td><td>86.84</td><td>86.40</td><td>90.79</td><td>82.20</td><td>90.46</td><td>88.21</td><td>85.66</td></tr><tr><td colspan=\"8\">PL PROBING WITH PRECEDED CONTEXT ONLY</td></tr><tr><td>ROBERTA</td><td>73.68</td><td>53.31</td><td>51.32</td><td>55.14</td><td>42.32</td><td>52.58</td><td>52.24</td></tr><tr><td>PRE-TRAIN W/ CODE ONLY</td><td>63.16</td><td>48.53</td><td>61.84</td><td>56.25</td><td>58.51</td><td>58.97</td><td>56.71</td></tr><tr><td>CODEBERT (MLM)</td><td>65.79</td><td>50.74</td><td>59.21</td><td>62.03</td><td>54.98</td><td>59.95</td><td>59.12</td></tr><tr><td colspan=\"8\">NL PROBING</td></tr><tr><td>ROBERTA</td><td>50.00</td><td>72.31</td><td>54.72</td><td>61.57</td><td>61.61</td><td>65.75</td><td>61.21</td></tr><tr><td>PRE-TRAIN W/ CODE ONLY</td><td>55.00</td><td>67.69</td><td>60.38</td><td>68.06</td><td>65.02</td><td>68.49</td><td>65.19</td></tr><tr><td>CODEBERT (MLM)</td><td>65.00</td><td>89.23</td><td>66.67</td><td>76.85</td><td>73.37</td><td>79.45</td><td>74.53</td></tr></table>",
                "caption": "Table 3: Statistics of the data for NL-PL probing and the performance of different pre-trained models. Accuracies \\((\\%)\\) are reported. Best results in each group are in bold."
            },
            {
                "block_id": 2,
                "type": "text",
                "bbox": [
                    285,
                    1227,
                    1215,
                    1841
                ],
                "angle": 0,
                "content": "datasets in different programming languages are extremely unbalanced, we report the accumulated metric with the same way. We use CodeBERT (MLM) here because its output layer naturally fits for probing. Results show that CodeBERT performs better than baselines on almost all languages on both NL and PL probing. The numbers with only preceding contexts are lower than that with bidirectional contexts, which suggests that code completion is challenging. We leave it as a future work."
            },
            {
                "block_id": 3,
                "type": "text",
                "bbox": [
                    285,
                    1852,
                    1215,
                    2248
                ],
                "angle": 0,
                "content": "We further give a case study on PL-NL probing. We mask NL token and PL token separately, and report the predicted probabilities of RoBERTa and CodeBERT. Figure 3 illustrates the example of a python code<sup>7</sup>. We can see that RoBERTa fails in both cases, whereas CodeBERT makes the correct prediction in both NL and PL settings."
            },
            {
                "block_id": 4,
                "type": "title",
                "bbox": [
                    287,
                    2287,
                    1046,
                    2339
                ],
                "angle": 0,
                "content": "4.3 Code Documentation Generation"
            },
            {
                "block_id": 5,
                "type": "text",
                "bbox": [
                    285,
                    2360,
                    1218,
                    2981
                ],
                "angle": 0,
                "content": "Although the pre-training objective of CodeBERT does not include generation-based objectives (Lewis et al., 2019), we would like to investigate to what extent does CodeBERT perform on generation tasks. Specifically, we study code-to-NL generation, and report results for the documentation generation task on CodeSearchNet Corpus in six programming languages. Since the generated documentations are short and higher order n-grams may not overlap, we remedy this problem by using smoothed BLEU score (Lin and Och, 2004)."
            },
            {
                "block_id": 6,
                "type": "image",
                "bbox": [
                    1280,
                    1227,
                    2188,
                    1775
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 7,
                "type": "table",
                "bbox": [
                    1275,
                    1792,
                    2188,
                    2059
                ],
                "angle": 0,
                "content": "<table><tr><td colspan=\"2\"></td><td>max</td><td>min</td><td>less</td><td>greater</td></tr><tr><td rowspan=\"2\">NL</td><td>Roberta</td><td>96.24%</td><td>3.73%</td><td>0.02%</td><td>0.01%</td></tr><tr><td>CodeBERT (MLM)</td><td>39.38%</td><td>60.60%</td><td>0.02%</td><td>0.0003%</td></tr><tr><td rowspan=\"2\">PL</td><td>Roberta</td><td>95.85%</td><td>4.15%</td><td>-</td><td>-</td></tr><tr><td>CodeBERT (MLM)</td><td>0.001%</td><td>99.999%</td><td>-</td><td>-</td></tr></table>"
            },
            {
                "block_id": 8,
                "type": "image_caption",
                "bbox": [
                    1265,
                    2090,
                    2195,
                    2297
                ],
                "angle": 0,
                "content": "Figure 3: Case study on python language. Masked tokens in NL (in blue) and PL (in yellow) are separately applied. Predicted probabilities of RoBERTa and CodeBERT are given."
            },
            {
                "block_id": 9,
                "type": "text",
                "bbox": [
                    1262,
                    2343,
                    2195,
                    2904
                ],
                "angle": 0,
                "content": "Model Comparisons We compare our model with several baselines, including a RNN-based model with attention mechanism (Sutskever et al., 2014), the Transformer (Vaswani et al., 2017), RoBERTa and the model pre-trained on code only. To demonstrate the effectiveness of CodeBERT on code-to-NL generation tasks, we adopt various pre-trained models as encoders and keep the hyperparameters consistent. Detailed hyper-parameters are given in Appendix B.3."
            },
            {
                "block_id": 10,
                "type": "text",
                "bbox": [
                    1265,
                    2911,
                    2198,
                    3195
                ],
                "angle": 0,
                "content": "Table 4 shows the results with different models for the code-to-documentation generation task. As we can see, models pre-trained on programming language outperform RoBERTa, which illustrates that pre-training models on programming"
            },
            {
                "block_id": 11,
                "type": "page_footnote",
                "bbox": [
                    287,
                    3013,
                    1220,
                    3192
                ],
                "angle": 0,
                "content": "The example comes from https://github.com/peri-source/peri/blob/61beed5deaaf978ab31ed716e8470d86ba639867/peri/comp/psfcalc.py#L994-L1002"
            },
            {
                "block_id": 12,
                "type": "page_number",
                "bbox": [
                    1195,
                    3230,
                    1292,
                    3279
                ],
                "angle": 0,
                "content": "1542"
            }
        ]
    },
    {
        "page_id": 7,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "table",
                "bbox": [
                    401,
                    252,
                    2071,
                    645
                ],
                "angle": 0,
                "content": "<table><tr><td>MODEL</td><td>RUBY</td><td>JAVASCIPT</td><td>GO</td><td>PYTHON</td><td>JAVA</td><td>PHP</td><td>OVERALL</td></tr><tr><td>SEQ2SEQ</td><td>9.64</td><td>10.21</td><td>13.98</td><td>15.93</td><td>15.09</td><td>21.08</td><td>14.32</td></tr><tr><td>TRANSFORMER</td><td>11.18</td><td>11.59</td><td>16.38</td><td>15.81</td><td>16.26</td><td>22.12</td><td>15.56</td></tr><tr><td>ROBERTA</td><td>11.17</td><td>11.90</td><td>17.72</td><td>18.14</td><td>16.47</td><td>24.02</td><td>16.57</td></tr><tr><td>PRE-TRAIN W/ CODE ONLY</td><td>11.91</td><td>13.99</td><td>17.78</td><td>18.58</td><td>17.50</td><td>24.34</td><td>17.35</td></tr><tr><td>CODEBERT (RTD)</td><td>11.42</td><td>13.27</td><td>17.53</td><td>18.29</td><td>17.35</td><td>24.10</td><td>17.00</td></tr><tr><td>CODEBERT (MLM)</td><td>11.57</td><td>14.41</td><td>17.78</td><td>18.77</td><td>17.38</td><td>24.85</td><td>17.46</td></tr><tr><td>CODEBERT (RTD+MLM)</td><td>12.16</td><td>14.90</td><td>18.07</td><td>19.06</td><td>17.65</td><td>25.16</td><td>17.83</td></tr></table>",
                "caption": "Table 4: Results on Code-to-Documentation generation, evaluated with smoothed BLEU-4 score."
            },
            {
                "block_id": 2,
                "type": "text",
                "bbox": [
                    285,
                    796,
                    1215,
                    1076
                ],
                "angle": 0,
                "content": "language could improve code-to-NL generation. Besides, results in the Table 4 show that CodeBERT pre-trained with RTD and MLM objectives brings a gain of 1.3 BLEU score over RoBERTa overall and achieve the state-of-the-art performance\\(^{8}\\)."
            },
            {
                "block_id": 3,
                "type": "title",
                "bbox": [
                    287,
                    1119,
                    1027,
                    1231
                ],
                "angle": 0,
                "content": "4.4 Generalization to Programming Languages NOT in Pre-training"
            },
            {
                "block_id": 4,
                "type": "text",
                "bbox": [
                    285,
                    1252,
                    1218,
                    1982
                ],
                "angle": 0,
                "content": "We would like to evaluate CodeBERT on the programming language which is never seen in the pretraining step. To this end, we study the task of generating a natural language summary of a C# code snippet. We conduct experiments on the dataset of CodeNN (Iyer et al., 2016)<sup>9</sup>, which consists of 66,015 pairs of questions and answers automatically collected from StackOverflow. This dataset is challenging since the scale of dataset is orders of magnitude smaller than CodeSearchNet Corpus. We evaluate models using smoothed BLEU-4 score and use the same evaluation scripts as Iyer et al. (2016)."
            },
            {
                "block_id": 5,
                "type": "table",
                "bbox": [
                    315,
                    2024,
                    1183,
                    2669
                ],
                "angle": 0,
                "content": "<table><tr><td>MODEL</td><td>BLEU</td></tr><tr><td>MOSES (KOEHN ET AL., 2007)</td><td>11.57</td></tr><tr><td>IR</td><td>13.66</td></tr><tr><td>SUM-NN (RUSH ET AL., 2015)</td><td>19.31</td></tr><tr><td>2-LAYER BILSTM</td><td>19.78</td></tr><tr><td>TRANSFORMER (VASWANI ET AL., 2017)</td><td>19.68</td></tr><tr><td>TREELSTM (TAI ET AL., 2015)</td><td>20.11</td></tr><tr><td>CODENN (IYER ET AL., 2016)</td><td>20.53</td></tr><tr><td>CODE2SEQ (ALON ET AL., 2019)</td><td>23.04</td></tr><tr><td>ROBERTA</td><td>19.81</td></tr><tr><td>PRE-TRAIN W/ CODE ONLY</td><td>20.65</td></tr><tr><td>CODEBERT (RTD)</td><td>22.14</td></tr><tr><td>CODEBERT (MLM)</td><td>22.32</td></tr><tr><td>CODEBERT (MLM+RTD)</td><td>22.36</td></tr></table>",
                "caption": "Table 5: Code-to-NL generation on C# language."
            },
            {
                "block_id": 7,
                "type": "text",
                "bbox": [
                    287,
                    2837,
                    1215,
                    3062
                ],
                "angle": 0,
                "content": "Model Comparisons Table 5 shows that our model with MLM and RTD pre-training objectives achieves 22.36 BLEU score and improves by 2.55 points over RoBERTa, which illustrates CodeBERT"
            },
            {
                "block_id": 8,
                "type": "text",
                "bbox": [
                    1265,
                    796,
                    2198,
                    1525
                ],
                "angle": 0,
                "content": "could generalize better to other programming language which is never seen in the pre-training step. However, our model achieve slightly lower results than code2seq (Alon et al., 2019). The main reason could be that code2seq makes use of compositional paths in its abstract syntax tree (AST) while CodeBERT only takes original code as the input. We have trained a version of CodeBERT by traversing the tree structure of AST following a certain order, but applying that model does not bring improvements on generation tasks. This shows a potential direction to improve CodeBERT by incorporating AST."
            },
            {
                "block_id": 9,
                "type": "title",
                "bbox": [
                    1267,
                    1575,
                    1597,
                    1627
                ],
                "angle": 0,
                "content": "5 Conclusion"
            },
            {
                "block_id": 10,
                "type": "text",
                "bbox": [
                    1262,
                    1666,
                    2198,
                    2623
                ],
                "angle": 0,
                "content": "In this paper, we present CodeBERT, which to the best of our knowledge is the first large bimodal pre-trained model for natural language and programming language. We train CodeBERT on both bimodal and unimodal data, and show that fine-tuning CodeBERT achieves state-of-the-art performance on downstream tasks including natural language code search and code-to-documentation generation. To further investigate the knowledge embodied in pre-trained models, we formulate the task of NL-PL probing and create a dataset for probing. We regard the probing task as a cloze-style answer selection problem, and curate distractors for both NL and PL parts. Results show that, with model parameters fixed, CodeBERT performs better than RoBERTa and a continuously trained model using codes only."
            },
            {
                "block_id": 11,
                "type": "text",
                "bbox": [
                    1262,
                    2627,
                    2198,
                    3195
                ],
                "angle": 0,
                "content": "There are many potential directions for further research on this field. First, one could learn better generators with bimodal evidence or more complicated neural architecture to improve the replaced token detection objective. Second, the loss functions of CodeBERT mainly target on NL-PL understanding tasks. Although CodeBERT achieves strong BLEU scores on code-to-documentation generation, the CodeBERT itself could be further improved by generation-related learning objectives."
            },
            {
                "block_id": 12,
                "type": "page_footnote",
                "bbox": [
                    342,
                    3094,
                    1185,
                    3143
                ],
                "angle": 0,
                "content": "<sup>8</sup>We further give some output examples in Appendix E."
            },
            {
                "block_id": 13,
                "type": "page_footnote",
                "bbox": [
                    342,
                    3143,
                    1156,
                    3188
                ],
                "angle": 0,
                "content": "<sup>9</sup>https://github.com/sriniiyer/codenn"
            },
            {
                "block_id": 14,
                "type": "list",
                "bbox": [
                    342,
                    3094,
                    1185,
                    3188
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 15,
                "type": "page_number",
                "bbox": [
                    1195,
                    3230,
                    1292,
                    3279
                ],
                "angle": 0,
                "content": "1543"
            }
        ]
    },
    {
        "page_id": 8,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "text",
                "bbox": [
                    285,
                    263,
                    1223,
                    655
                ],
                "angle": 0,
                "content": "How to successfully incorporate AST into the pretraining step is also an attractive direction. Third, we plan to apply CodeBERT to more NL-PL related tasks, and extend it to more programming languages. Flexible and powerful domain/language adaptation methods are necessary to generalize well."
            },
            {
                "block_id": 1,
                "type": "title",
                "bbox": [
                    287,
                    705,
                    697,
                    764
                ],
                "angle": 0,
                "content": "Acknowledgments"
            },
            {
                "block_id": 2,
                "type": "text",
                "bbox": [
                    285,
                    796,
                    1215,
                    1245
                ],
                "angle": 0,
                "content": "Xiaocheng Feng is the corresponding author of this work. We thank the anonymous reviewers for their insightful comments. Zhangyin Feng, Xiaocheng Feng, Bing Qin and Ting Liu are supported by the National Key R&D Program of China via grant 2018YFB1005103 and National Natural Science Foundation of China (NSFC) via grant 61632011 and 61772156."
            },
            {
                "block_id": 3,
                "type": "title",
                "bbox": [
                    290,
                    1343,
                    535,
                    1399
                ],
                "angle": 0,
                "content": "References"
            },
            {
                "block_id": 4,
                "type": "ref_text",
                "bbox": [
                    292,
                    1427,
                    1223,
                    1617
                ],
                "angle": 0,
                "content": "Uri Alon, Shaked Brody, Omer Levy, and Eran Yahav. 2019. code2seq: Generating sequences from structured representations of code. International Conference on Learning Representations."
            },
            {
                "block_id": 5,
                "type": "ref_text",
                "bbox": [
                    292,
                    1652,
                    1215,
                    1929
                ],
                "angle": 0,
                "content": "Kyunghyun Cho, Bart Van Merrienboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. 2014. Learning phrase representations using rnN encoder-decoder for statistical machine translation. arXiv preprint arXiv:1406.1078."
            },
            {
                "block_id": 6,
                "type": "ref_text",
                "bbox": [
                    292,
                    1967,
                    1215,
                    2203
                ],
                "angle": 0,
                "content": "Kevin Clark, Minh-Thang Luong, Quoc V. Le, and Christopher D. Manning. 2020. {ELECTRA}: Pretraining text encoders as discriminators rather than generators. In International Conference on Learning Representations."
            },
            {
                "block_id": 7,
                "type": "ref_text",
                "bbox": [
                    292,
                    2238,
                    1215,
                    2424
                ],
                "angle": 0,
                "content": "Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2018. Bert: Pre-training of deep bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805."
            },
            {
                "block_id": 8,
                "type": "ref_text",
                "bbox": [
                    292,
                    2462,
                    1220,
                    2648
                ],
                "angle": 0,
                "content": "Xiaodong Gu, Hongyu Zhang, and Sunghun Kim. 2018. Deep code search. In 2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE), pages 933-944. IEEE."
            },
            {
                "block_id": 9,
                "type": "ref_text",
                "bbox": [
                    292,
                    2687,
                    1215,
                    2876
                ],
                "angle": 0,
                "content": "Hamel Husain, Ho-Hsiang Wu, Tiferet Gazit, Miltiadis Allamanis, and Marc Brockschmidt. 2019. Code-searchnet challenge: Evaluating the state of semantic code search. arXiv preprint arXiv:1909.09436."
            },
            {
                "block_id": 10,
                "type": "ref_text",
                "bbox": [
                    292,
                    2911,
                    1215,
                    3192
                ],
                "angle": 0,
                "content": "Srinivasan Iyer, Ioannis Konstas, Alvin Cheung, and Luke Zettlemoyer. 2016. Summarizing source code using a neural attention model. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 2073-2083."
            },
            {
                "block_id": 11,
                "type": "list",
                "bbox": [
                    292,
                    1427,
                    1223,
                    3192
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 12,
                "type": "ref_text",
                "bbox": [
                    1272,
                    270,
                    2195,
                    361
                ],
                "angle": 0,
                "content": "Dan Jurafsky. 2000. Speech & language processing. Pearson Education India."
            },
            {
                "block_id": 13,
                "type": "ref_text",
                "bbox": [
                    1272,
                    399,
                    2195,
                    582
                ],
                "angle": 0,
                "content": "Aditya Kanade, Petros Maniatis, Gogul Balakrishnan, and Kensen Shi. 2019. Pre-trained contextual embedding of source code. arXiv preprint arXiv:2001.00059."
            },
            {
                "block_id": 14,
                "type": "ref_text",
                "bbox": [
                    1272,
                    624,
                    2195,
                    761
                ],
                "angle": 0,
                "content": "Yoon Kim. 2014. Convolutional neural networks for sentence classification. arXiv preprint arXiv:1408.5882."
            },
            {
                "block_id": 15,
                "type": "ref_text",
                "bbox": [
                    1272,
                    803,
                    2195,
                    1217
                ],
                "angle": 0,
                "content": "Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris Callison-Burch, Marcello Federico, Nicola Bertoldi, Brooke Cowan, Wade Shen, Christine Moran, Richard Zens, et al. 2007. Moses: Open source toolkit for statistical machine translation. In Proceedings of the 45th annual meeting of the association for computational linguistics companion volume proceedings of the demo and poster sessions, pages 177-180."
            },
            {
                "block_id": 16,
                "type": "ref_text",
                "bbox": [
                    1272,
                    1255,
                    2195,
                    1529
                ],
                "angle": 0,
                "content": "Mike Lewis, Yinhan Liu, Naman Goyal, Marjan Ghazvininejad, Abdelrahman Mohamed, Omer Levy, Ves Stoyanov, and Luke Zettlemoyer. 2019. Bart: Denoising sequence-to-sequence pre-training for natural language generation, translation, and comprehension. arXiv preprint arXiv:1910.13461."
            },
            {
                "block_id": 17,
                "type": "ref_text",
                "bbox": [
                    1272,
                    1568,
                    2195,
                    1845
                ],
                "angle": 0,
                "content": "Chin-Yew Lin and Franz Josef Och. 2004. Orange: a method for evaluating automatic evaluation metrics for machine translation. In Proceedings of the 20th international conference on Computational Linguistics, page 501. Association for Computational Linguistics."
            },
            {
                "block_id": 18,
                "type": "ref_text",
                "bbox": [
                    1272,
                    1883,
                    2195,
                    2118
                ],
                "angle": 0,
                "content": "Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. 2019. Roberta: A robustly optimized bert pretraining approach. arXiv preprint arXiv:1907.11692."
            },
            {
                "block_id": 19,
                "type": "ref_text",
                "bbox": [
                    1272,
                    2153,
                    2195,
                    2385
                ],
                "angle": 0,
                "content": "Jiasen Lu, Dhruv Batra, Devi Parikh, and Stefan Lee. 2019. Vilbert: Pretraining task-agnostic visiolinguistic representations for vision-and-language tasks. In Advances in Neural Information Processing Systems, pages 13-23."
            },
            {
                "block_id": 20,
                "type": "ref_text",
                "bbox": [
                    1272,
                    2424,
                    2195,
                    2560
                ],
                "angle": 0,
                "content": "Bhaskar Mitra, Nick Craswell, et al. 2018. An introduction to neural information retrieval. Foundations and Trends® in Information Retrieval, 13(1):1-126."
            },
            {
                "block_id": 21,
                "type": "ref_text",
                "bbox": [
                    1272,
                    2599,
                    2195,
                    2785
                ],
                "angle": 0,
                "content": "Matthew E Peters, Mark Neumann, Mohit Iyyer, Matt Gardner, Christopher Clark, Kenton Lee, and Luke Zettlemoyer. 2018. Deep contextualized word representations. arXiv preprint arXiv:1802.05365."
            },
            {
                "block_id": 22,
                "type": "ref_text",
                "bbox": [
                    1272,
                    2823,
                    2195,
                    3009
                ],
                "angle": 0,
                "content": "Fabio Petroni, Tim Roktäschel, Patrick Lewis, Anton Bakhtin, Yuxiang Wu, Alexander H Miller, and Sebastian Riedel. 2019. Language models as knowledge bases? arXiv preprint arXiv:1909.01066."
            },
            {
                "block_id": 23,
                "type": "ref_text",
                "bbox": [
                    1272,
                    3048,
                    2195,
                    3188
                ],
                "angle": 0,
                "content": "Telmo Pires, Eva Schlinger, and Dan Garrette. 2019. How multilingual is multilingual bert? arXiv preprint arXiv:1906.01502."
            },
            {
                "block_id": 24,
                "type": "list",
                "bbox": [
                    1272,
                    270,
                    2195,
                    3188
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 25,
                "type": "page_number",
                "bbox": [
                    1195,
                    3234,
                    1292,
                    3276
                ],
                "angle": 0,
                "content": "1544"
            }
        ]
    },
    {
        "page_id": 9,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "text",
                "bbox": [
                    292,
                    266,
                    1255,
                    554
                ],
                "angle": 0,
                "content": "Alec Radford, Karthik Narasimhan, Tim Salimans, and Ilya Sutskever. 2018. Improving language understanding by generative pre-training. URL https://s3-us-west-2. amazonaws. com/openai-assetss/researchcovers/languageunsupervised/language understanding paper.pdf."
            },
            {
                "block_id": 1,
                "type": "text",
                "bbox": [
                    290,
                    589,
                    1220,
                    820
                ],
                "angle": 0,
                "content": "Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J Liu. 2019. Exploring the limits of transfer learning with a unified text-to-text transformer. arXiv preprint arXiv:1910.10683."
            },
            {
                "block_id": 2,
                "type": "text",
                "bbox": [
                    290,
                    859,
                    1220,
                    1048
                ],
                "angle": 0,
                "content": "Alexander M Rush, Sumit Chopra, and Jason Weston. 2015. A neural attention model for abstractive sentence summarization. arXiv preprint arXiv:1509.00685."
            },
            {
                "block_id": 3,
                "type": "text",
                "bbox": [
                    290,
                    1087,
                    1220,
                    1280
                ],
                "angle": 0,
                "content": "Chen Sun, Austin Myers, Carl Vondrick, Kevin Murphy, and Cordelia Schmid. 2019. Videobert: A joint model for video and language representation learning. arXiv preprint arXiv:1904.01766."
            },
            {
                "block_id": 4,
                "type": "text",
                "bbox": [
                    290,
                    1315,
                    1220,
                    1508
                ],
                "angle": 0,
                "content": "Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014. Sequence to sequence learning with neural networks. In Advances in neural information processing systems, pages 3104-3112."
            },
            {
                "block_id": 5,
                "type": "text",
                "bbox": [
                    290,
                    1547,
                    1220,
                    1736
                ],
                "angle": 0,
                "content": "Kai Sheng Tai, Richard Socher, and Christopher D Manning. 2015. Improved semantic representations from tree-structured long short-term memory networks. arXiv preprint arXiv:1503.00075."
            },
            {
                "block_id": 6,
                "type": "text",
                "bbox": [
                    290,
                    1775,
                    1220,
                    1964
                ],
                "angle": 0,
                "content": "Alon Talmor, Yanai Elazar, Yoav Goldberg, and Jonathan Berant. 2019. olympics-on what language model pre-training captures. arXiv preprint arXiv:1912.13283."
            },
            {
                "block_id": 7,
                "type": "text",
                "bbox": [
                    290,
                    2003,
                    1220,
                    2241
                ],
                "angle": 0,
                "content": "Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Lukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In Advances in neural information processing systems, pages 5998-6008."
            },
            {
                "block_id": 8,
                "type": "text",
                "bbox": [
                    292,
                    2273,
                    1220,
                    2599
                ],
                "angle": 0,
                "content": "Yonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V Le, Mohammad Norouzi, Wolfgang Macherey, Maxim Krikun, Yuan Cao, Qin Gao, Klaus Macherey, et al. 2016. Google's neural machine translation system: Bridging the gap between human and machine translation. arXiv preprint arXiv:1609.08144."
            },
            {
                "block_id": 9,
                "type": "text",
                "bbox": [
                    290,
                    2641,
                    1220,
                    2876
                ],
                "angle": 0,
                "content": "Zhilin Yang, Zihang Dai, Yiming Yang, Jaime Carbonell, Ruslan Salakhutdinov, and Quoc V Le. 2019. Xlnet: Generalized autoregressive pretraining for language understanding. arXiv preprint arXiv:1906.08237."
            },
            {
                "block_id": 10,
                "type": "title",
                "bbox": [
                    290,
                    2929,
                    677,
                    2981
                ],
                "angle": 0,
                "content": "A Data Statistic"
            },
            {
                "block_id": 11,
                "type": "text",
                "bbox": [
                    287,
                    3023,
                    1218,
                    3188
                ],
                "angle": 0,
                "content": "Data statistics of the training/validation/testing data splits for six programming languages are given in Table 6."
            },
            {
                "block_id": 12,
                "type": "table",
                "bbox": [
                    1295,
                    256,
                    2163,
                    606
                ],
                "angle": 0,
                "content": "<table><tr><td>CODE SEARCH</td><td>TRAINING</td><td>DEV</td><td>TESTING</td></tr><tr><td>GO</td><td>635,635</td><td>28,483</td><td>14,291</td></tr><tr><td>JAVA</td><td>908,886</td><td>30,655</td><td>26,909</td></tr><tr><td>JAVAsCRIPT</td><td>247,773</td><td>16,505</td><td>6,483</td></tr><tr><td>PHP</td><td>1,047,406</td><td>52,029</td><td>28,391</td></tr><tr><td>PYTHON</td><td>824,342</td><td>46,213</td><td>22,176</td></tr><tr><td>RUBY</td><td>97,580</td><td>4,417</td><td>2,279</td></tr></table>",
                "caption": "Table 6: Data statistics about the CodeSearchNet Corpus for natural language code search."
            },
            {
                "block_id": 14,
                "type": "title",
                "bbox": [
                    1267,
                    824,
                    1647,
                    880
                ],
                "angle": 0,
                "content": "B Train Details"
            },
            {
                "block_id": 15,
                "type": "title",
                "bbox": [
                    1267,
                    922,
                    1637,
                    978
                ],
                "angle": 0,
                "content": "B.1 Pre-training"
            },
            {
                "block_id": 16,
                "type": "text",
                "bbox": [
                    1265,
                    1003,
                    2198,
                    1568
                ],
                "angle": 0,
                "content": "We train CodeBERT on one NVIDIA DGX-2 machine using FP16. It combines 16 interconnected NVIDIA Tesla V100 with 32GB memory. We use the following set of hyper-parameters to train models: batchsize is 2,048 and learning rate is 5e-4. We use Adam to update the parameters and set the number of warmup steps as 10K. We set the max length as 512 and the max training step is 100K. Training 1,000 batches of data costs 600 minutes with MLM objective, 120 minutes with RTD objective."
            },
            {
                "block_id": 17,
                "type": "title",
                "bbox": [
                    1267,
                    1613,
                    1627,
                    1666
                ],
                "angle": 0,
                "content": "B.2 CodeSearch"
            },
            {
                "block_id": 18,
                "type": "text",
                "bbox": [
                    1265,
                    1694,
                    2195,
                    2087
                ],
                "angle": 0,
                "content": "In the fine-turning step, we set the learning rate as 1e-5, the batch size as 64, the max sequence length as 200 and the max fine-tuning epoch as 8. As the same with pre-training, We use Adam to update the parameters. We choose the model performed best on the development set, and use that to evaluate on the test set."
            },
            {
                "block_id": 19,
                "type": "title",
                "bbox": [
                    1267,
                    2139,
                    1942,
                    2252
                ],
                "angle": 0,
                "content": "B.3 Code Summarization on Six Programming Languages"
            },
            {
                "block_id": 20,
                "type": "text",
                "bbox": [
                    1265,
                    2273,
                    2198,
                    2732
                ],
                "angle": 0,
                "content": "We use Transformer with 6 layers, 768 dimensional hidden states and 12 attention heads as our decoder in all settings. We set the max length of input and inference as 256 and 64, respectively. We use the Adam optimizer to update model parameters. The learning rate and the batch size are 5e-5 and 64, respectively. We tune hyperparameters and perform early stopping on the development set."
            },
            {
                "block_id": 21,
                "type": "title",
                "bbox": [
                    1267,
                    2774,
                    1937,
                    2827
                ],
                "angle": 0,
                "content": "B.4 Code Summarization on C#"
            },
            {
                "block_id": 22,
                "type": "text",
                "bbox": [
                    1265,
                    2852,
                    2198,
                    3195
                ],
                "angle": 0,
                "content": "Since state-of-the-art methods use RNN as their decoder, we choose a 2-layer GRU with an attention mechanism as our decoder for a comparison. We fine-tune models using a grid search with the following set of hyper-parameters: batchsize is in \\(\\{32, 64\\}\\) and learning rate is in \\(\\{2e-5, 5e-5\\}\\). We report"
            },
            {
                "block_id": 23,
                "type": "page_number",
                "bbox": [
                    1195,
                    3230,
                    1292,
                    3279
                ],
                "angle": 0,
                "content": "1545"
            }
        ]
    },
    {
        "page_id": 10,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "text",
                "bbox": [
                    287,
                    266,
                    1215,
                    375
                ],
                "angle": 0,
                "content": "the number when models achieve best performance on the development set."
            },
            {
                "block_id": 1,
                "type": "title",
                "bbox": [
                    287,
                    413,
                    1049,
                    473
                ],
                "angle": 0,
                "content": "C Learning Curve of CodeSearch"
            },
            {
                "block_id": 2,
                "type": "text",
                "bbox": [
                    287,
                    501,
                    1218,
                    726
                ],
                "angle": 0,
                "content": "From Figure 4, we can see that CodeBERT performs better at the early stage, which reflects that CodeBERT provides good initialization for learning downstream tasks."
            },
            {
                "block_id": 3,
                "type": "image",
                "bbox": [
                    302,
                    792,
                    751,
                    1255
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 4,
                "type": "image",
                "bbox": [
                    759,
                    796,
                    1205,
                    1255
                ],
                "angle": 0,
                "content": null,
                "caption": "Figure 4: Learning curve of different pre-trained models in the fine-tuning step. We show results on Python and Java."
            },
            {
                "block_id": 6,
                "type": "title",
                "bbox": [
                    287,
                    1487,
                    642,
                    1536
                ],
                "angle": 0,
                "content": "D Late Fusion"
            },
            {
                "block_id": 7,
                "type": "text",
                "bbox": [
                    285,
                    1575,
                    1215,
                    2417
                ],
                "angle": 0,
                "content": "In section §4.1, we show that CodeBERT performs well in the setting where natural languages and codes have early interactions. Here, we investigate whether CodeBERT is good at working as a unified encoder. We apply CodeBERT for natural language code search in a later fusion setting, where CodeBERT first encodes NL and PL separately, and then calculates the similarity by dot-product. In this way, code search is equivalent to find the nearest codes in the shared vector space. This scenario also facilitates the use of CodeBERT in an online system, where the representations of codes are calculated in advance. In the runtime, a system only needs to compute the representation of NL and vector-based dot-product."
            },
            {
                "block_id": 8,
                "type": "text",
                "bbox": [
                    285,
                    2420,
                    1215,
                    2645
                ],
                "angle": 0,
                "content": "We fine-tune CodeBERT with the following objective, which maximizes the dot-product of the ground truth while minimizing the dot-product of distractors."
            },
            {
                "block_id": 9,
                "type": "equation",
                "bbox": [
                    332,
                    2662,
                    1213,
                    2855
                ],
                "angle": 0,
                "content": "\\[\n- \\frac {1}{N} \\sum_ {i} \\log \\left(\\frac {\\exp \\left(E n c \\left(c _ {i}\\right) ^ {\\top} E n c \\left(w _ {i}\\right)\\right)}{\\sum_ {j} \\exp \\left(E n c \\left(c _ {j}\\right) ^ {\\top} E n c \\left(w _ {i}\\right)\\right)}\\right) \\tag {15}\n\\]"
            },
            {
                "block_id": 10,
                "type": "text",
                "bbox": [
                    287,
                    2911,
                    1213,
                    3073
                ],
                "angle": 0,
                "content": "Results are given in Table 7. We just do this setting on two languages with a relatively small amount of data."
            },
            {
                "block_id": 11,
                "type": "text",
                "bbox": [
                    287,
                    3080,
                    1213,
                    3192
                ],
                "angle": 0,
                "content": "We can see that CodeBERT performs better than RoBERTa and the model pre-trained with codes"
            },
            {
                "block_id": 12,
                "type": "table",
                "bbox": [
                    1319,
                    284,
                    2138,
                    512
                ],
                "angle": 0,
                "content": "<table><tr><td>MODEL</td><td>RUBY</td><td>GO</td></tr><tr><td>ROBERTA</td><td>0.0043</td><td>0.0030</td></tr><tr><td>PRE-TRAIN W/ CODE ONLY</td><td>0.1648</td><td>0.4179</td></tr><tr><td>CODEBERT</td><td>0.6870</td><td>0.8372</td></tr></table>",
                "caption": "Table 7: Results on natural language code search by late fusion."
            },
            {
                "block_id": 14,
                "type": "text",
                "bbox": [
                    1265,
                    726,
                    2193,
                    950
                ],
                "angle": 0,
                "content": "only. And late fusion performs comparable with the standard way. What's more, late fusion is more efficient and this setting could be used in an online system."
            },
            {
                "block_id": 15,
                "type": "title",
                "bbox": [
                    1267,
                    992,
                    1610,
                    1048
                ],
                "angle": 0,
                "content": "E Case Study"
            },
            {
                "block_id": 16,
                "type": "text",
                "bbox": [
                    1265,
                    1080,
                    2195,
                    1248
                ],
                "angle": 0,
                "content": "To qualitatively analyze the effectiveness of CodeBERT, we give some cases for code search and code documentation generation tasks."
            },
            {
                "block_id": 17,
                "type": "text",
                "bbox": [
                    1265,
                    1252,
                    2193,
                    1476
                ],
                "angle": 0,
                "content": "Considering the limited space, we only give the top2 results of the query for python programming language. As show in Figure 5, search results are very relevant with query."
            },
            {
                "block_id": 18,
                "type": "text",
                "bbox": [
                    1265,
                    1476,
                    2193,
                    1697
                ],
                "angle": 0,
                "content": "Figure 6 and Figure 7 show the outputs with different models for the code documentation generation task. As we can see, CodeBERT performs better than all baselines."
            },
            {
                "block_id": 19,
                "type": "page_number",
                "bbox": [
                    1195,
                    3230,
                    1292,
                    3279
                ],
                "angle": 0,
                "content": "1546"
            }
        ]
    },
    {
        "page_id": 11,
        "ocr_results": [
            {
                "block_id": 1,
                "type": "code",
                "bbox": [
                    382,
                    329,
                    818,
                    375
                ],
                "angle": 0,
                "content": "create file and write something",
                "caption": "Search Results (top2)"
            },
            {
                "block_id": 3,
                "type": "code",
                "bbox": [
                    382,
                    466,
                    1567,
                    768
                ],
                "angle": 0,
                "content": "https://github.com/darknessomi/musicbox/blob/master/NEMbox/util.py#L37-L40   \ndef create_file(path, default \\(=\\) \"\\n\"): if not os.path.exists(path): with open(path, \"w\") as f: f.write(default)"
            },
            {
                "block_id": 4,
                "type": "code",
                "bbox": [
                    384,
                    834,
                    1567,
                    880
                ],
                "angle": 0,
                "content": "https://github.com/datakortet/yamldirs/blob/master/yamldirs/filemaker.py#L114-L118"
            },
            {
                "block_id": 5,
                "type": "code",
                "bbox": [
                    384,
                    915,
                    1538,
                    1126
                ],
                "angle": 0,
                "content": "def make_file(self, filename, content):  \n    '''Create a new file with name `filename` and content `content`.  \n    '''with open(filename, 'w') as fp:  \n        fp.write(content)"
            },
            {
                "block_id": 6,
                "type": "image_caption",
                "bbox": [
                    285,
                    1185,
                    2193,
                    1290
                ],
                "angle": 0,
                "content": "Figure 5: Python CodeSearch example. The results are searched from 1,156,085 python code data. We only give the top2 results because space is limited."
            },
            {
                "block_id": 7,
                "type": "code",
                "bbox": [
                    374,
                    1361,
                    1255,
                    1564
                ],
                "angle": 0,
                "content": "public void addWriteErrorResult(final BulkWriteError writeError, final IndexMap indexMap) {\n    notNull(\"writeError\", writeError);\n    mergeWriteErrors(asList(writeError), indexMap);\n}",
                "caption": "Gold: Add a write error result"
            },
            {
                "block_id": 9,
                "type": "code",
                "bbox": [
                    379,
                    1690,
                    1200,
                    1908
                ],
                "angle": 0,
                "content": "CodeBERT: Add a write error result.  \nPRE-TRAIN W/ CODEONLY : Merges the given write error.  \nRoberta: Add a write operation to the map.  \nTransformer: Adds an error to the write map."
            },
            {
                "block_id": 10,
                "type": "code",
                "bbox": [
                    382,
                    1922,
                    719,
                    1964
                ],
                "angle": 0,
                "content": "RNN: Add an error map."
            },
            {
                "block_id": 11,
                "type": "image_caption",
                "bbox": [
                    712,
                    2024,
                    1768,
                    2073
                ],
                "angle": 0,
                "content": "Figure 6: Java code documentation generation output example."
            },
            {
                "block_id": 12,
                "type": "code",
                "bbox": [
                    379,
                    2150,
                    1699,
                    2659
                ],
                "angle": 0,
                "content": "def create_or_update(self, list_id, subscriber_hash, data):  \n    subscriber_hash = check subscribed_hash(subscriber_hash)  \n    self.list_id = list_id  \n    self subscribers_hash = subscriber_hash  \n    if 'email_address' not in data:  \n        raise ValueError('The list member must have an email_address')  \n    check_email(data['email_address'])  \n    if 'status_if_new' not in data:  \n        raise ValueError('The list member must have a status_if_new')  \n    if data['status_if_new'] not in ['subscribed', 'unsubscribed', 'cleaned', 'pending', 'transactional']:  \n        raise ValueError('The list member status_if_new must be one of \" subscribed\", \"unsubscribed\", \"cleaned\", \"pending\", or \"transactional\"))  \n    return self._mc_client._put(url= self._build_path(list_id, 'members', subscriber_hash), data=data)",
                "caption": "Gold: Add or update a list member."
            },
            {
                "block_id": 14,
                "type": "code",
                "bbox": [
                    384,
                    2774,
                    1185,
                    3048
                ],
                "angle": 0,
                "content": "CodeBERT: Create or update a list member.  \nPRE-TRAIN W/ CODEONLY: Create or update a subscriber.  \nRoberta: Create or update an existing record.  \nTransformer: Create or update a subscription.  \nRNN: Creates or updates an email address."
            },
            {
                "block_id": 15,
                "type": "image_caption",
                "bbox": [
                    687,
                    3101,
                    1793,
                    3153
                ],
                "angle": 0,
                "content": "Figure 7: Python code documentation generation output example."
            },
            {
                "block_id": 16,
                "type": "page_number",
                "bbox": [
                    1195,
                    3230,
                    1292,
                    3276
                ],
                "angle": 0,
                "content": "1547"
            }
        ]
    }
]