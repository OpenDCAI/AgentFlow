[
    {
        "page_id": 0,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "title",
                "bbox": [
                    444,
                    284,
                    2046,
                    357
                ],
                "angle": 0,
                "content": "NCRF++: An Open-source Neural Sequence Labeling Toolkit"
            },
            {
                "block_id": 1,
                "type": "text",
                "bbox": [
                    975,
                    473,
                    1523,
                    533
                ],
                "angle": 0,
                "content": "Jie Yang and Yue Zhang"
            },
            {
                "block_id": 2,
                "type": "text",
                "bbox": [
                    764,
                    533,
                    1734,
                    589
                ],
                "angle": 0,
                "content": "Singapore University of Technology and Design"
            },
            {
                "block_id": 3,
                "type": "text",
                "bbox": [
                    850,
                    592,
                    1647,
                    648
                ],
                "angle": 0,
                "content": "jie_yang@mymail.sutd.edu.sg"
            },
            {
                "block_id": 4,
                "type": "text",
                "bbox": [
                    937,
                    655,
                    1560,
                    708
                ],
                "angle": 0,
                "content": "yue_zhang@sutd.edu.sg"
            },
            {
                "block_id": 5,
                "type": "title",
                "bbox": [
                    654,
                    929,
                    848,
                    978
                ],
                "angle": 0,
                "content": "Abstract"
            },
            {
                "block_id": 6,
                "type": "text",
                "bbox": [
                    354,
                    1017,
                    1143,
                    1918
                ],
                "angle": 0,
                "content": "This paper describes NCRF++, a toolkit for neural sequence labeling. NCRF++ is designed for quick implementation of different neural sequence labeling models with a CRF inference layer. It provides users with an inference for building the custom model structure through configuration file with flexible neural feature design and utilization. Built on PyTorch<sup>1</sup>, the core operations are calculated in batch, making the toolkit efficient with the acceleration of GPU. It also includes the implementations of most state-of-the-art neural sequence labeling models such as LSTM-CRF, facilitating reproducing and refinement on those methods."
            },
            {
                "block_id": 7,
                "type": "title",
                "bbox": [
                    287,
                    1957,
                    650,
                    2006
                ],
                "angle": 0,
                "content": "1 Introduction"
            },
            {
                "block_id": 8,
                "type": "text",
                "bbox": [
                    285,
                    2045,
                    1215,
                    2662
                ],
                "angle": 0,
                "content": "Sequence labeling is one of the most fundamental NLP models, which is used for many tasks such as named entity recognition (NER), chunking, word segmentation and part-of-speech (POS) tagging. It has been traditionally investigated using statistical approaches (Lafferty et al., 2001; Ratinov and Roth, 2009), where conditional random fields (CRF) (Lafferty et al., 2001) has been proven as an effective framework, by taking discrete features as the representation of input sequence (Sha and Pereira, 2003; Keerthi and Sundararajan, 2007)."
            },
            {
                "block_id": 9,
                "type": "text",
                "bbox": [
                    285,
                    2666,
                    1215,
                    3115
                ],
                "angle": 0,
                "content": "With the advances of deep learning, neural sequence labeling models have achieved state-of-the-art for many tasks (Ling et al., 2015; Ma and Hovy, 2016; Peters et al., 2017). Features are extracted automatically through network structures including long short-term memory (LSTM) (Hochreiter and Schmidhuber, 1997) and convolution neural network (CNN) (LeCun et al., 1989),"
            },
            {
                "block_id": 10,
                "type": "code",
                "bbox": [
                    1300,
                    922,
                    2123,
                    1326
                ],
                "angle": 0,
                "content": "```java\n##NetworkConfiguration## \nuse_crf=True \nword_seq_feature=LSTM \nword_seq_layer=1 \nchar_seq_feature=CNN \nfeature=[POS] emb_dir=None emb_size=10 \nfeature=[Cap] emb_dir=% (cap_emb_dir) \n##Hyperparameters## \n..."
            },
            {
                "block_id": 11,
                "type": "image_caption",
                "bbox": [
                    1391,
                    1368,
                    2071,
                    1424
                ],
                "angle": 0,
                "content": "Figure 1: Configuration file segment"
            },
            {
                "block_id": 12,
                "type": "text",
                "bbox": [
                    1265,
                    1504,
                    2193,
                    1782
                ],
                "angle": 0,
                "content": "with distributed word representations. Similar to discrete models, a CRF layer is used in many state-of-the-art neural sequence labeling models for capturing label dependencies (Collobert et al., 2011; Lample et al., 2016; Peters et al., 2017)."
            },
            {
                "block_id": 13,
                "type": "text",
                "bbox": [
                    1265,
                    1785,
                    2193,
                    2627
                ],
                "angle": 0,
                "content": "There exist several open-source statistical CRF sequence labeling toolkits, such as \\(\\mathrm{CRF}++^2\\), CRF-Suite (Okazaki, 2007) and FlexCRFs (Phan et al., 2004), which provide users with flexible means of feature extraction, various training settings and decoding formats, facilitating quick implementation and extension on state-of-the-art models. On the other hand, there is limited choice for neural sequence labeling toolkits. Although many authors released their code along with their sequence labeling papers (Lample et al., 2016; Ma and Hovy, 2016; Liu et al., 2018), the implementations are mostly focused on specific model structures and specific tasks. Modifying or extending can need enormous coding."
            },
            {
                "block_id": 14,
                "type": "text",
                "bbox": [
                    1265,
                    2634,
                    2195,
                    3023
                ],
                "angle": 0,
                "content": "In this paper, we present Neural \\(\\mathrm{CRF}++\\) \\((\\mathrm{NCRF}++)^3\\), a neural sequence labeling toolkit based on PyTorch, which is designed for solving general sequence labeling tasks with effective and efficient neural models. It can be regarded as the neural version of \\(\\mathrm{CRF}++\\), with both take the CoNLL data format as input and can add hand-"
            },
            {
                "block_id": 15,
                "type": "page_footnote",
                "bbox": [
                    1329,
                    3055,
                    2064,
                    3101
                ],
                "angle": 0,
                "content": "\\(^{2}\\)https://taku910.github.io/rgbpp/"
            },
            {
                "block_id": 16,
                "type": "page_footnote",
                "bbox": [
                    1280,
                    3101,
                    2188,
                    3188
                ],
                "angle": 0,
                "content": "3Code is available at https://github.com/jiesutd/NCRFpp."
            },
            {
                "block_id": 17,
                "type": "list",
                "bbox": [
                    1280,
                    3055,
                    2188,
                    3188
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 18,
                "type": "page_footnote",
                "bbox": [
                    342,
                    3139,
                    796,
                    3188
                ],
                "angle": 0,
                "content": "<sup>1</sup>http://pytorch.org/"
            },
            {
                "block_id": 19,
                "type": "page_number",
                "bbox": [
                    1218,
                    3234,
                    1267,
                    3276
                ],
                "angle": 0,
                "content": "74"
            },
            {
                "block_id": 20,
                "type": "footer",
                "bbox": [
                    275,
                    3301,
                    2198,
                    3399
                ],
                "angle": 0,
                "content": "Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics-System Demonstrations, pages 74-79 Melbourne, Australia, July 15 - 20, 2018. ©2018 Association for Computational Linguistics"
            }
        ]
    },
    {
        "page_id": 1,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "image",
                "bbox": [
                    352,
                    263,
                    2158,
                    996
                ],
                "angle": 0,
                "content": null,
                "caption": "Figure 2: NCRF++ for sentence “I love Bruce Lee”. Green, red, yellow and blue circles represent character embeddings, word embeddings, character sequence representations and word sequence representations, respectively. The grey circles represent the embeddings of sparse features."
            },
            {
                "block_id": 2,
                "type": "text",
                "bbox": [
                    285,
                    1290,
                    1213,
                    1515
                ],
                "angle": 0,
                "content": "crafted features to CRF framework conveniently. We take the layerwise implementation, which includes character sequence layer, word sequence layer and inference layer. NCRF++ is:"
            },
            {
                "block_id": 3,
                "type": "text",
                "bbox": [
                    285,
                    1532,
                    1213,
                    2038
                ],
                "angle": 0,
                "content": "- Fully configurable: users can design their neural models only through a configuration file without any code work. Figure 1 shows a segment of the configuration file. It builds a LSTM-CRF framework with CNN to encode character sequence (the same structure as Ma and Hovy (2016)), plus POS and Cap features, within 10 lines. This demonstrates the convenience of designing neural models using NCRF++."
            },
            {
                "block_id": 4,
                "type": "text",
                "bbox": [
                    285,
                    2052,
                    1213,
                    2837
                ],
                "angle": 0,
                "content": "- Flexible with features: human-defined features have been proved useful in neural sequence labeling (Collobert et al., 2011; Chiu and Nichols, 2016). Similar to the statistical toolkits, NCRF++ supports user-defined features but using distributed representations through lookup tables, which can be initialized randomly or from external pretrained embeddings (embedding directory: emb_dir in Figure 1). In addition, NCRF++ integrates several state-of-the-art automatic feature extractors, such as CNN and LSTM for character sequences, leading easy reproduction of many recent work (Lample et al., 2016; Chiu and Nichols, 2016; Ma and Hovy, 2016)."
            },
            {
                "block_id": 5,
                "type": "text",
                "bbox": [
                    285,
                    2855,
                    1215,
                    3192
                ],
                "angle": 0,
                "content": "- Effective and efficient: we reimplement several state-of-the-art neural models (Lample et al., 2016; Ma and Hovy, 2016) using NCRF++. Experiments show models built in NCRF++ give comparable performance with reported results in the literature. Besides, NCRF++ is implemented"
            },
            {
                "block_id": 6,
                "type": "text",
                "bbox": [
                    1265,
                    1290,
                    2190,
                    1455
                ],
                "angle": 0,
                "content": "using batch calculation, which can be accelerated using GPU. Our experiments demonstrate that NCRF++ as an effective and efficient toolkit."
            },
            {
                "block_id": 7,
                "type": "text",
                "bbox": [
                    1265,
                    1466,
                    2190,
                    1627
                ],
                "angle": 0,
                "content": "- Function enriched: NCRF++ extends the Viterbi algorithm (Viterbi, 1967) to enable decoding \\( n \\) best sequence labels with their probabilities."
            },
            {
                "block_id": 8,
                "type": "text",
                "bbox": [
                    1265,
                    1634,
                    2193,
                    1971
                ],
                "angle": 0,
                "content": "Taking NER, Chunking and POS tagging as typical examples, we investigate the performance of models built in NCRF++, the influence of human-defined and automatic features, the performance of nbest decoding and the running speed with the batch size. Detail results are shown in Section 3."
            },
            {
                "block_id": 9,
                "type": "title",
                "bbox": [
                    1267,
                    2024,
                    1835,
                    2080
                ],
                "angle": 0,
                "content": "2 NCRF++ Architecture"
            },
            {
                "block_id": 10,
                "type": "text",
                "bbox": [
                    1262,
                    2118,
                    2193,
                    3192
                ],
                "angle": 0,
                "content": "The framework of NCRF++ is shown in Figure 2. NCRF++ is designed with three layers: a character sequence layer; a word sequence layer and inference layer. For each input word sequence, words are represented with word embeddings. The character sequence layer can be used to automatically extract word level features by encoding the character sequence within the word. Arbitrary handcrafted features such as capitalization [Cap], POS tag [POS], prefixes [Pre] and suffixes [Suf] are also supported by NCRF++. Word representations are the concatenation of word embeddings (red circles), character sequence encoding hidden vector (yellow circles) and handcrafted neural features (grey circles). Then the word sequence layer takes the word representations as input and extracts the sentence level features, which are fed into the inference layer to assign a label to each word. When building the network, users"
            },
            {
                "block_id": 11,
                "type": "page_number",
                "bbox": [
                    1218,
                    3234,
                    1267,
                    3279
                ],
                "angle": 0,
                "content": "75"
            }
        ]
    },
    {
        "page_id": 2,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "text",
                "bbox": [
                    285,
                    266,
                    1210,
                    599
                ],
                "angle": 0,
                "content": "only need to edit the configuration file to configure the model structure, training settings and hyperparameters. We use layer-wised encapsulation in our implementation. Users can extend NCRF++ by defining their own structure in any layer and integrate it into NCRF++ easily."
            },
            {
                "block_id": 1,
                "type": "title",
                "bbox": [
                    287,
                    641,
                    640,
                    694
                ],
                "angle": 0,
                "content": "2.1 Layer Units"
            },
            {
                "block_id": 2,
                "type": "title",
                "bbox": [
                    287,
                    715,
                    957,
                    768
                ],
                "angle": 0,
                "content": "2.1.1 Character Sequence Layer"
            },
            {
                "block_id": 3,
                "type": "text",
                "bbox": [
                    285,
                    778,
                    1210,
                    1227
                ],
                "angle": 0,
                "content": "The character sequence layer integrates several typical neural encoders for character sequence information, such as RNN and CNN. It is easy to select our existing encoder through the configuration file (by setting char_seqfeature in Figure 1). Characters are represented by character embeddings (green circles in Figure 2), which serve as the input of character sequence layer."
            },
            {
                "block_id": 4,
                "type": "text",
                "bbox": [
                    285,
                    1234,
                    1210,
                    1624
                ],
                "angle": 0,
                "content": "- Character RNN and its variants Gated Recurrent Unit (GRU) and LSTM are supported by NCRF++. The character sequence layer uses bidirectional RNN to capture the left-to-right and right-to-left sequence information, and concatenates the final hidden states of two RNNs as the encoder of the input character sequence."
            },
            {
                "block_id": 5,
                "type": "text",
                "bbox": [
                    287,
                    1627,
                    1213,
                    1796
                ],
                "angle": 0,
                "content": "- Character CNN takes a sliding window to capture local features, and then uses a max-pooling for aggregated encoding of the character sequence."
            },
            {
                "block_id": 6,
                "type": "list",
                "bbox": [
                    285,
                    1234,
                    1213,
                    1796
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 7,
                "type": "title",
                "bbox": [
                    287,
                    1827,
                    870,
                    1883
                ],
                "angle": 0,
                "content": "2.1.2 Word Sequence Layer"
            },
            {
                "block_id": 8,
                "type": "text",
                "bbox": [
                    285,
                    1894,
                    1210,
                    2508
                ],
                "angle": 0,
                "content": "Similar to the character sequence layer, NCRF++ supports both RNN and CNN as the word sequence feature extractor. The selection can be configured through word_seq_feature in Figure 1. The input of the word sequence layer is a word representation, which may include word embeddings, character sequence representations and handcrafted neural features (the combination depends on the configuration file). The word sequence layer can be stacked, building a deeper feature extractor."
            },
            {
                "block_id": 9,
                "type": "text",
                "bbox": [
                    285,
                    2515,
                    1210,
                    3020
                ],
                "angle": 0,
                "content": "- Word RNN together with GRU and LSTM are available in NCRF++, which are popular structures in the recent literature (Huang et al., 2015; Lample et al., 2016; Ma and Hovy, 2016; Yang et al., 2017). Bidirectional RNNs are supported to capture the left and right contexted information of each word. The hidden vectors for both directions on each word are concatenated to represent the corresponding word."
            },
            {
                "block_id": 10,
                "type": "text",
                "bbox": [
                    287,
                    3023,
                    1210,
                    3188
                ],
                "angle": 0,
                "content": "- Word CNN utilizes the same sliding window as character CNN, while a nonlinear function (Glorot et al., 2011) is attached with the extracted fea"
            },
            {
                "block_id": 11,
                "type": "list",
                "bbox": [
                    285,
                    2515,
                    1210,
                    3188
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 12,
                "type": "text",
                "bbox": [
                    1265,
                    266,
                    2190,
                    431
                ],
                "angle": 0,
                "content": "tures. Batch normalization (Ioffe and Szegedy, 2015) and dropout (Srivastava et al., 2014) are also supported to follow the features."
            },
            {
                "block_id": 13,
                "type": "title",
                "bbox": [
                    1267,
                    470,
                    1729,
                    522
                ],
                "angle": 0,
                "content": "2.1.3 Inference Layer"
            },
            {
                "block_id": 14,
                "type": "text",
                "bbox": [
                    1262,
                    536,
                    2193,
                    1045
                ],
                "angle": 0,
                "content": "The inference layer takes the extracted word sequence representations as features and assigns labels to the word sequence. NCRF++ supports both softmax and CRF as the output layer. A linear layer firstly maps the input sequence representations to label vocabulary size scores, which are used to either model the label probabilities of each word through simple softmax or calculate the label score of the whole sequence."
            },
            {
                "block_id": 15,
                "type": "text",
                "bbox": [
                    1265,
                    1048,
                    2193,
                    1441
                ],
                "angle": 0,
                "content": "- Softmax maps the label scores into a probability space. Due to the support of parallel decoding, softmax is much more efficient than CRF and works well on some sequence labeling tasks (Ling et al., 2015). In the training process, various loss functions such as negative likelihood loss, cross entropy loss are supported."
            },
            {
                "block_id": 16,
                "type": "text",
                "bbox": [
                    1265,
                    1445,
                    2193,
                    1897
                ],
                "angle": 0,
                "content": "- CRF captures label dependencies by adding transition scores between neighboring labels. NCRF++ supports CRF trained with the sentence-level maximum log-likelihood loss. During the decoding process, the Viterbi algorithm is used to search the label sequence with the highest probability. In addition, NCRF++ extends the decoding algorithm with the support of nbest output."
            },
            {
                "block_id": 17,
                "type": "list",
                "bbox": [
                    1265,
                    1048,
                    2193,
                    1897
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 18,
                "type": "title",
                "bbox": [
                    1267,
                    1936,
                    1664,
                    1989
                ],
                "angle": 0,
                "content": "2.2 User Interface"
            },
            {
                "block_id": 19,
                "type": "text",
                "bbox": [
                    1262,
                    2013,
                    2193,
                    2518
                ],
                "angle": 0,
                "content": "NCRF++ provides users with abundant network configuration interfaces, including the network structure, input and output directory setting, training settings and hyperparameters. By editing a configuration file, users can build most state-of-the-art neural sequence labeling models. On the other hand, all the layers above are designed as \"plug-in\" modules, where user-defined layer can be integrated seamlessly."
            },
            {
                "block_id": 20,
                "type": "title",
                "bbox": [
                    1267,
                    2557,
                    1694,
                    2609
                ],
                "angle": 0,
                "content": "2.2.1 Configuration"
            },
            {
                "block_id": 21,
                "type": "text",
                "bbox": [
                    1262,
                    2627,
                    2190,
                    3073
                ],
                "angle": 0,
                "content": "- Networks can be configured in the three layers as described in Section 2.1. It controls the choice of neural structures in character and word levels with char_seq_feature and word_seq_feature, respectively. The inference layer is set by use_crf. It also defines the usage of handcrafted features and their properties in feature."
            },
            {
                "block_id": 22,
                "type": "text",
                "bbox": [
                    1265,
                    3080,
                    2190,
                    3192
                ],
                "angle": 0,
                "content": "- I/O is the input and output file directory configuration. It includes training_dir,"
            },
            {
                "block_id": 23,
                "type": "list",
                "bbox": [
                    1262,
                    2627,
                    2190,
                    3192
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 24,
                "type": "page_number",
                "bbox": [
                    1218,
                    3234,
                    1267,
                    3279
                ],
                "angle": 0,
                "content": "76"
            }
        ]
    },
    {
        "page_id": 3,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "table",
                "bbox": [
                    292,
                    259,
                    1205,
                    845
                ],
                "angle": 0,
                "content": "<table><tr><td rowspan=\"2\">Models</td><td>NER</td><td>chunking</td><td>POS</td></tr><tr><td>F1-value</td><td>F1-value</td><td>Acc</td></tr><tr><td>Nochar+WCNN+CRF</td><td>88.90</td><td>94.23</td><td>96.99</td></tr><tr><td>CLSTM+WCNN+CRF</td><td>90.70</td><td>94.76</td><td>97.38</td></tr><tr><td>CCNN+WCNN+CRF</td><td>90.43</td><td>94.77</td><td>97.33</td></tr><tr><td>Nochar+WLSTM+CRF</td><td>89.45</td><td>94.49</td><td>97.20</td></tr><tr><td>CLSTM+WLSTM+CRF</td><td>91.20</td><td>95.00</td><td>97.49</td></tr><tr><td>CCNN+WLSTM+CRF</td><td>91.35</td><td>95.06</td><td>97.46</td></tr><tr><td>Lample et al. (2016)</td><td>90.94</td><td>-</td><td>97.51</td></tr><tr><td>Ma and Hovy (2016)</td><td>91.21</td><td>-</td><td>97.55</td></tr><tr><td>Yang et al. (2017)</td><td>91.20</td><td>94.66</td><td>97.55</td></tr><tr><td>Peters et al. (2017)</td><td>90.87</td><td>95.00</td><td>-</td></tr></table>",
                "caption": "Table 1: Results on three benchmarks."
            },
            {
                "block_id": 2,
                "type": "text",
                "bbox": [
                    285,
                    1024,
                    1213,
                    1245
                ],
                "angle": 0,
                "content": "dev_dir, test_dir, raw_dir, pretrained character or word embedding (char_emb_dim or word_emb_dim), and decode file directory (decode_dir)."
            },
            {
                "block_id": 3,
                "type": "text",
                "bbox": [
                    285,
                    1248,
                    1213,
                    1473
                ],
                "angle": 0,
                "content": "- Training includes the loss function (loss_function), optimizer (optimizer)<sup>4</sup>, shuffle training instances train_shuffle and average batch loss ave_batch_loss."
            },
            {
                "block_id": 4,
                "type": "text",
                "bbox": [
                    285,
                    1476,
                    1213,
                    2038
                ],
                "angle": 0,
                "content": "- Hyperparameter includes most of the parameters in the networks and training such as learning rate (lr) and its decay (lr Decay), hidden layer size of word and character (hidden_dim and char Hidden_dim), nbest size (nbest), batch size (batch_size), dropout (dropout), etc. Note that the embedding size of each handcrafted feature is configured in the networks configuration (feature = [POS] emb_dir = None, emb_size = 10 in Figure 1)."
            },
            {
                "block_id": 5,
                "type": "list",
                "bbox": [
                    285,
                    1248,
                    1213,
                    2038
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 6,
                "type": "title",
                "bbox": [
                    287,
                    2069,
                    632,
                    2118
                ],
                "angle": 0,
                "content": "2.2.2 Extension"
            },
            {
                "block_id": 7,
                "type": "text",
                "bbox": [
                    285,
                    2136,
                    1213,
                    2701
                ],
                "angle": 0,
                "content": "Users can write their own custom modules on all three layers, and user-defined layers can be integrated into the system easily. For example, if a user wants to define a custom character sequence layer with a specific neural structure, he/she only needs to implement the part between input character sequence indexes to sequence representations. All the other networks structures can be used and controlled through the configuration file. A README file is given on this."
            },
            {
                "block_id": 8,
                "type": "title",
                "bbox": [
                    287,
                    2739,
                    607,
                    2788
                ],
                "angle": 0,
                "content": "3 Evaluation"
            },
            {
                "block_id": 9,
                "type": "title",
                "bbox": [
                    287,
                    2830,
                    560,
                    2883
                ],
                "angle": 0,
                "content": "3.1 Settings"
            },
            {
                "block_id": 10,
                "type": "text",
                "bbox": [
                    285,
                    2904,
                    1213,
                    3073
                ],
                "angle": 0,
                "content": "To evaluate the performance of our toolkit, we conduct the experiments on several datasets. For NER task, CoNLL 2003 data (Tjong Kim Sang"
            },
            {
                "block_id": 11,
                "type": "table",
                "bbox": [
                    1275,
                    259,
                    2185,
                    592
                ],
                "angle": 0,
                "content": "<table><tr><td colspan=\"2\">Features</td><td>P</td><td>R</td><td>F</td></tr><tr><td>Baseline</td><td>WLSTM+CRF</td><td>80.44</td><td>87.88</td><td>89.15</td></tr><tr><td rowspan=\"3\">Human Feature</td><td>+POS</td><td>90.61</td><td>89.28</td><td>89.94</td></tr><tr><td>+Cap</td><td>90.74</td><td>90.43</td><td>90.58</td></tr><tr><td>+POS+Cap</td><td>90.92</td><td>90.27</td><td>90.59</td></tr><tr><td rowspan=\"2\">Auto Feature</td><td>+CLSTM</td><td>91.22</td><td>91.17</td><td>91.20</td></tr><tr><td>+CCNN</td><td>91.66</td><td>91.04</td><td>91.35</td></tr></table>",
                "caption": "Table 2: Results using different features."
            },
            {
                "block_id": 13,
                "type": "text",
                "bbox": [
                    1262,
                    785,
                    2193,
                    1525
                ],
                "angle": 0,
                "content": "and De Meulder, 2003) with the standard split is used. For the chunking task, we perform experiments on CoNLL 2000 shared task (Tjong Kim Sang and Buchholz, 2000), data split is following Reimers and Gurevych (2017). For POS tagging, we use the same data and split with Ma and Hovy (2016). We test different combinations of character representations and word sequence representations on these three benchmarks. Hyperparameters are mostly following Ma and Hovy (2016) and almost keep the same in all these experiments<sup>5</sup>. Standard SGD with a decaying learning rate is used as the optimizer."
            },
            {
                "block_id": 14,
                "type": "title",
                "bbox": [
                    1267,
                    1568,
                    1528,
                    1613
                ],
                "angle": 0,
                "content": "3.2 Results"
            },
            {
                "block_id": 15,
                "type": "text",
                "bbox": [
                    1262,
                    1645,
                    2193,
                    2266
                ],
                "angle": 0,
                "content": "Table 1 shows the results of six CRF-based models with different character sequence and word sequence representations on three benchmarks. State-of-the-art results are also listed. In this table, \"Nochar\" suggests a model without character sequence information. \"CLSTM\" and \"CCNN\" represent models using LSTM and CNN to encode character sequence, respectively. Similarly, \"WLSTM\" and \"WCNN\" indicate that the model uses LSTM and CNN to represent word sequence, respectively."
            },
            {
                "block_id": 16,
                "type": "text",
                "bbox": [
                    1262,
                    2269,
                    2193,
                    3058
                ],
                "angle": 0,
                "content": "As shown in Table 1, \"WCNN\" based models consistently underperform the \"WLSTM\" based models, showing the advantages of LSTM on capturing global features. Character information can improve model performance significantly, while using LSTM or CNN give similar improvement. Most of state-of-the-art models utilize the framework of word LSTM-CRF with character LSTM or CNN features (correspond to \"CLSTM+WLSTM+CRF\" and \"CCNN+WLSTM+CRF\" of our models) (Lample et al., 2016; Ma and Hovy, 2016; Yang et al., 2017; Peters et al., 2017). Our implementations can achieve comparable results, with better NER and"
            },
            {
                "block_id": 17,
                "type": "page_footnote",
                "bbox": [
                    1267,
                    3097,
                    2193,
                    3192
                ],
                "angle": 0,
                "content": "<sup>5</sup>We use a smaller learning rate (0.005) on CNN based word sequence representation."
            },
            {
                "block_id": 18,
                "type": "page_footnote",
                "bbox": [
                    287,
                    3097,
                    1210,
                    3188
                ],
                "angle": 0,
                "content": "4Currently NCRF++ supports five optimizers: SGD/AdaGrad/AdaDelta/RMSProp/Adam."
            },
            {
                "block_id": 19,
                "type": "page_number",
                "bbox": [
                    1218,
                    3234,
                    1267,
                    3279
                ],
                "angle": 0,
                "content": "77"
            }
        ]
    },
    {
        "page_id": 4,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "image",
                "bbox": [
                    307,
                    263,
                    1193,
                    919
                ],
                "angle": 0,
                "content": null,
                "caption": "Figure 3: Oracle performance with nbest."
            },
            {
                "block_id": 2,
                "type": "text",
                "bbox": [
                    285,
                    1129,
                    1215,
                    1525
                ],
                "angle": 0,
                "content": "chunking performances and slightly lower POS tagging accuracy. Note that we use almost the same hyperparameters across all the experiments to achieve the results, which demonstrates the robustness of our implementation. The full experimental results and analysis are published in Yang et al. (2018)."
            },
            {
                "block_id": 3,
                "type": "title",
                "bbox": [
                    287,
                    1571,
                    816,
                    1624
                ],
                "angle": 0,
                "content": "3.3 Influence of Features"
            },
            {
                "block_id": 4,
                "type": "text",
                "bbox": [
                    285,
                    1645,
                    1215,
                    2666
                ],
                "angle": 0,
                "content": "We also investigate the influence of different features on system performance. Table 2 shows the results on the NER task. POS tag and capital indicator are two common features on NER tasks (Collobert et al., 2011; Huang et al., 2015; Strubell et al., 2017). In our implementation, each POS tag or capital indicator feature is mapped as 10-dimension feature embeddings through randomly initialized feature lookup table \\(^{6}\\). The feature embeddings are concatenated with the word embeddings as the representation of the corresponding word. Results show that both human features [POS] and [Cap] can contribute the NER system, this is consistent with previous observations (Collobert et al., 2011; Chiu and Nichols, 2016). By utilizing LSTM or CNN to encode character sequence automatically, the system can achieve better performance on NER task."
            },
            {
                "block_id": 5,
                "type": "title",
                "bbox": [
                    287,
                    2708,
                    724,
                    2767
                ],
                "angle": 0,
                "content": "3.4 N best Decoding"
            },
            {
                "block_id": 6,
                "type": "text",
                "bbox": [
                    285,
                    2785,
                    1215,
                    3069
                ],
                "angle": 0,
                "content": "We investigate nbest Viterbi decoding on NER dataset through the best model \"CCNN+WLSTM+CRF\". Figure 3 shows the oracle entity F1-values and token accuracies with different nbest sizes. The oracle F1-value"
            },
            {
                "block_id": 7,
                "type": "image",
                "bbox": [
                    1285,
                    270,
                    2178,
                    919
                ],
                "angle": 0,
                "content": null,
                "caption": "Figure 4: Speed with batch size."
            },
            {
                "block_id": 9,
                "type": "text",
                "bbox": [
                    1262,
                    1119,
                    2198,
                    1515
                ],
                "angle": 0,
                "content": "rises significantly with the increasement of nbest size, reaching \\(97.47\\%\\) at \\(n = 10\\) from the baseline of \\(91.35\\%\\). The token level accuracy increases from \\(98.00\\%\\) to \\(99.39\\%\\) in 10-best. Results show that the nbest outputs include the gold entities and labels in a large coverage, which greatly enlarges the performance of successor tasks."
            },
            {
                "block_id": 10,
                "type": "title",
                "bbox": [
                    1265,
                    1550,
                    1818,
                    1610
                ],
                "angle": 0,
                "content": "3.5 Speed with Batch Size"
            },
            {
                "block_id": 11,
                "type": "text",
                "bbox": [
                    1262,
                    1624,
                    2198,
                    2360
                ],
                "angle": 0,
                "content": "As NCRF++ is implemented on batched calculation, it can be greatly accelerated through parallel computing through GPU. We test the system speeds on both training and decoding process on NER dataset using a Nvidia GTX 1080 GPU. As shown in Figure 4, both the training and the decoding speed can be significantly accelerated through a large batch size. The decoding speed reaches saturation at batch size 100, while the training speed keeps growing. The decoding speed and training speed of NCRF++ are over 2000 sentences/second and 1000 sentences/second, respectively, demonstrating the efficiency of our implementation."
            },
            {
                "block_id": 12,
                "type": "title",
                "bbox": [
                    1265,
                    2399,
                    1597,
                    2452
                ],
                "angle": 0,
                "content": "4 Conclusion"
            },
            {
                "block_id": 13,
                "type": "text",
                "bbox": [
                    1262,
                    2487,
                    2198,
                    3167
                ],
                "angle": 0,
                "content": "We presented NCRF++, an open-source neural sequence labeling toolkit, which has a CRF architecture with configurable neural representation layers. Users can design custom neural models through the configuration file. NCRF++ supports flexible feature utilization, including handcrafted features and automatically extracted features. It can also generate nbest label sequences rather than the best one. We conduct a series of experiments and the results show models built on NCRF++ can achieve state-of-the-art results with an efficient running speed."
            },
            {
                "block_id": 14,
                "type": "page_footnote",
                "bbox": [
                    342,
                    3097,
                    1205,
                    3188
                ],
                "angle": 0,
                "content": "\\(^\\mathrm{6}\\) feature \\(=\\) [POS]emb_dir \\(\\equiv\\) Noneemb_size \\(= 10\\)   \nfeature \\(=\\) [Cap]emb_dir \\(\\equiv\\) Noneemb_size \\(= 10\\)"
            },
            {
                "block_id": 15,
                "type": "page_number",
                "bbox": [
                    1218,
                    3234,
                    1267,
                    3279
                ],
                "angle": 0,
                "content": "78"
            }
        ]
    },
    {
        "page_id": 5,
        "ocr_results": [
            {
                "block_id": 0,
                "type": "title",
                "bbox": [
                    292,
                    263,
                    535,
                    315
                ],
                "angle": 0,
                "content": "References"
            },
            {
                "block_id": 1,
                "type": "ref_text",
                "bbox": [
                    292,
                    343,
                    1250,
                    582
                ],
                "angle": 0,
                "content": "Jason Chiu and Eric Nichols. 2016. Named entity recognition with bidirectional LSTM-CNNs. Transactions of the Association for Computational Linguistics 4:357-370. https://transacl.org/ojs/index.php/tacl/article/view/792."
            },
            {
                "block_id": 2,
                "type": "ref_text",
                "bbox": [
                    292,
                    620,
                    1215,
                    852
                ],
                "angle": 0,
                "content": "Ronan Collobert, Jason Weston, Léon Bottou, Michael Karlen, Koray Kavukcuoglu, and Pavel Kuksa. 2011. Natural language processing (almost) from scratch. Journal of Machine Learning Research 12(Aug):2493-2537."
            },
            {
                "block_id": 3,
                "type": "ref_text",
                "bbox": [
                    292,
                    894,
                    1213,
                    1083
                ],
                "angle": 0,
                "content": "Xavier Glorot, Antoine Bordes, and Yoshua Bengio. 2011. Deep sparse rectifier neural networks. In International Conference on Artificial Intelligence and Statistics. pages 315-323."
            },
            {
                "block_id": 4,
                "type": "ref_text",
                "bbox": [
                    292,
                    1126,
                    1213,
                    1262
                ],
                "angle": 0,
                "content": "Sepp Hochreiter and Jürgen Schmidhuber. 1997. Long short-term memory. Neural computation 9(8):1735-1780."
            },
            {
                "block_id": 5,
                "type": "ref_text",
                "bbox": [
                    292,
                    1308,
                    1213,
                    1448
                ],
                "angle": 0,
                "content": "Zhiheng Huang, Wei Xu, and Kai Yu. 2015. Bidirectional LSTM-CRF models for sequence tagging. arXiv preprint arXiv:1508.01991."
            },
            {
                "block_id": 6,
                "type": "ref_text",
                "bbox": [
                    292,
                    1490,
                    1213,
                    1680
                ],
                "angle": 0,
                "content": "Sergey Ioffe and Christian Szegedy. 2015. Batch normalization: Accelerating deep network training by reducing internal covariate shift. In International Conference on Machine Learning, pages 448-456."
            },
            {
                "block_id": 7,
                "type": "ref_text",
                "bbox": [
                    292,
                    1718,
                    1213,
                    1862
                ],
                "angle": 0,
                "content": "S Sathiya Keerthi and Sellamanickam Sundararajan. 2007. Crf versus svm-struct for sequence labeling. Yahoo Research Technical Report."
            },
            {
                "block_id": 8,
                "type": "ref_text",
                "bbox": [
                    292,
                    1904,
                    1213,
                    2136
                ],
                "angle": 0,
                "content": "John Lafferty, Andrew McCallum, and Fernando CN Pereira. 2001. Conditional random fields: Probabilistic models for segmenting and labeling sequence data. In International Conference on Machine Learning. volume 1, pages 282-289."
            },
            {
                "block_id": 9,
                "type": "ref_text",
                "bbox": [
                    292,
                    2178,
                    1213,
                    2367
                ],
                "angle": 0,
                "content": "Guillaume Lample, Miguel Ballesteros, Sandeep Subramanian, Kazuya Kawakami, and Chris Dyer. 2016. Neural architectures for named entity recognition. In NAACL-HLT. pages 260-270."
            },
            {
                "block_id": 10,
                "type": "ref_text",
                "bbox": [
                    292,
                    2406,
                    1213,
                    2638
                ],
                "angle": 0,
                "content": "Yann LeCun, Bernhard Boser, John S Denker, Donnie Henderson, Richard E Howard, Wayne Hubbard, and Lawrence D Jackel. 1989. Backpropagation applied to handwritten zip code recognition. Neural computation 1(4):541-551."
            },
            {
                "block_id": 11,
                "type": "ref_text",
                "bbox": [
                    292,
                    2680,
                    1213,
                    2957
                ],
                "angle": 0,
                "content": "Wang Ling, Chris Dyer, Alan W Black, Isabel Trancoso, Ramon Fernandez, Silvio Amir, Luis Marujo, and Tiago Luis. 2015. Finding function in form: Compositional character models for open vocabulary word representation. In EMNLP. pages 1520-1530."
            },
            {
                "block_id": 12,
                "type": "ref_text",
                "bbox": [
                    292,
                    3002,
                    1213,
                    3185
                ],
                "angle": 0,
                "content": "Liyuan Liu, Jingbo Shang, Frank Xu, Xiang Ren, Huan Gui, Jian Peng, and Jiawei Han. 2018. Empower sequence labeling with task-aware neural language model. In AAAI."
            },
            {
                "block_id": 13,
                "type": "list",
                "bbox": [
                    292,
                    343,
                    1250,
                    3185
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 14,
                "type": "ref_text",
                "bbox": [
                    1272,
                    270,
                    2190,
                    406
                ],
                "angle": 0,
                "content": "Xuezhe Ma and Eduard Hovy. 2016. End-to-end sequence labeling via Bi-directional LSTM-CNNs-CRF. In ACL. volume 1, pages 1064-1074."
            },
            {
                "block_id": 15,
                "type": "ref_text",
                "bbox": [
                    1272,
                    442,
                    2190,
                    536
                ],
                "angle": 0,
                "content": "Naoaki Okazaki. 2007. Crfsuite: a fast implementation of conditional random fields (crfs)."
            },
            {
                "block_id": 16,
                "type": "ref_text",
                "bbox": [
                    1272,
                    571,
                    2190,
                    757
                ],
                "angle": 0,
                "content": "Matthew Peters, Waleed Ammar, Chandra Bhagavatula, and Russell Power. 2017. Semi-supervised sequence tagging with bidirectional language models. In ACL. volume 1, pages 1756-1765."
            },
            {
                "block_id": 17,
                "type": "ref_text",
                "bbox": [
                    1272,
                    792,
                    2190,
                    926
                ],
                "angle": 0,
                "content": "Xuan-Hieu Phan, Le-Minh Nguyen, and Cam-Tu Nguyen. 2004. Flexcrfs: Flexible conditional random fields."
            },
            {
                "block_id": 18,
                "type": "ref_text",
                "bbox": [
                    1272,
                    964,
                    2190,
                    1108
                ],
                "angle": 0,
                "content": "Lev Ratinov and Dan Roth. 2009. Design challenges and misconceptions in named entity recognition. In CoNLL. pages 147-155."
            },
            {
                "block_id": 19,
                "type": "ref_text",
                "bbox": [
                    1272,
                    1140,
                    2190,
                    1326
                ],
                "angle": 0,
                "content": "Nils Reimers and Iryna Gurevych. 2017. Reporting score distributions makes a difference: Performance study of lstm-networks for sequence tagging. In EMNLP. pages 338-348."
            },
            {
                "block_id": 20,
                "type": "ref_text",
                "bbox": [
                    1272,
                    1361,
                    2190,
                    1501
                ],
                "angle": 0,
                "content": "Fei Sha and Fernando Pereira. 2003. Shallow parsing with conditional random fields. In *NAACL-HLT*. pages 134-141."
            },
            {
                "block_id": 21,
                "type": "ref_text",
                "bbox": [
                    1272,
                    1532,
                    2190,
                    1764
                ],
                "angle": 0,
                "content": "Nitish Srivastava, Geoffrey E Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. 2014. Dropout: a simple way to prevent neural networks from overfitting. Journal of Machine Learning Research 15(1):1929-1958."
            },
            {
                "block_id": 22,
                "type": "ref_text",
                "bbox": [
                    1272,
                    1799,
                    2190,
                    1985
                ],
                "angle": 0,
                "content": "Emma Strubell, Patrick Verga, David Belanger, and Andrew McCallum. 2017. Fast and accurate entity recognition with iterated dilated convolutions. In EMNLP. pages 2670-2680."
            },
            {
                "block_id": 23,
                "type": "ref_text",
                "bbox": [
                    1272,
                    2020,
                    2190,
                    2297
                ],
                "angle": 0,
                "content": "Erik F Tjong Kim Sang and Sabine Buchholz. 2000. Introduction to the conll-2000 shared task: Chunking. In Proceedings of the 2nd workshop on Learning language in logic and the 4th conference on Computational natural language learning-Volume 7. pages 127-132."
            },
            {
                "block_id": 24,
                "type": "ref_text",
                "bbox": [
                    1272,
                    2329,
                    2190,
                    2518
                ],
                "angle": 0,
                "content": "Erik F Tjong Kim Sang and Fien De Meulder. 2003. Introduction to the conll-2003 shared task: Language-independent named entity recognition. In HLT-NAACL. pages 142-147."
            },
            {
                "block_id": 25,
                "type": "ref_text",
                "bbox": [
                    1272,
                    2550,
                    2190,
                    2736
                ],
                "angle": 0,
                "content": "Andrew Viterbi. 1967. Error bounds for convolutional codes and an asymptotically optimum decoding algorithm. IEEE transactions on Information Theory 13(2):260-269."
            },
            {
                "block_id": 26,
                "type": "ref_text",
                "bbox": [
                    1272,
                    2771,
                    2190,
                    2911
                ],
                "angle": 0,
                "content": "Jie Yang, Shuailong Liang, and Yue Zhang. 2018. Design challenges and misconceptions in neural sequence labeling. In COLING."
            },
            {
                "block_id": 27,
                "type": "ref_text",
                "bbox": [
                    1272,
                    2946,
                    2190,
                    3132
                ],
                "angle": 0,
                "content": "Zhilin Yang, Ruslan Salakhutdinov, and William W Cohen. 2017. Transfer learning for sequence tagging with hierarchical recurrent networks. In International Conference on Learning Representations."
            },
            {
                "block_id": 28,
                "type": "list",
                "bbox": [
                    1272,
                    270,
                    2190,
                    3132
                ],
                "angle": 0,
                "content": null
            },
            {
                "block_id": 29,
                "type": "page_number",
                "bbox": [
                    1218,
                    3234,
                    1267,
                    3276
                ],
                "angle": 0,
                "content": "79"
            }
        ]
    }
]